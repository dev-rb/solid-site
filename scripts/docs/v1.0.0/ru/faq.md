---
title: Часто задаваемые вопросы
description: Ответы на часто задаваемые вопросы
sort: 2
---

# Часто задаваемые вопросы

### 1. JSX без VDOM? Это пароварка? Я слышал, что это невозможно от авторов других фреймворков.

Это возможно, когда у вас нет модели обновления React. JSX - это шаблонный DSL, как и любой другой. Просто в некоторых моментах более гибкий. Иногда вставка произвольного JavaScript кода может быть сложной задачей, но ничем не отличается от поддержки spread-операторов. Так что нет, это не пароварка, а подход, который оказался одним из самых эффективных.

Настоящая выгода заключается ее расширяемости. У вас есть компилятор, работающий на вас, который дает вам оптимальные собственные обновления DOM, а так же у вас есть вся свобода библиотеки, например, такой как React, для написания компонентов с использованием таких методов, как `Render Props` и компонентов более высокого порядка, наряду с вашими реактивными хуками. Не нравится, как работает поток управления Solid? Напиши свой.

### 2. Почему Solid такой производительный?

Так хотелось бы указать что-то одно, но на самом деле это комбинация многих важных дизайнерских решений:

1. Явная реактивность. Отслеживаются только те вещи, которые должны быть реактивными.
2. Компилируй с учетом первоначального создания. Solid использует эвристику, чтобы уменьшить количество выполняемых вычислений, но сохранить ключевые обновления детализированными и производительными.
3. Реактивные выражения - это просто функции. Это позволяет использовать «исчезающие компоненты» с ленивой оценкой свойств. Удаляя ненужные оболочки и накладные расходы на синхронизацию.

В настоящее время эти уникальные методы в сочетании дают Solid преимущество над конкурентами.

### 3. Существует ли React-Compat?

Нет. И, вероятно, никогда не будет существовать. Хотя API-интерфейсы похожи, и компоненты часто можно перемещать с небольшими изменениями, модель обновления принципиально отличается. Компоненты React визуализируются снова и снова, поэтому код за пределами хуков работает совсем по-другому. Замыкания и правила хуков не только не нужны, их можно использовать способами, которые здесь не работают.

С другой стороны, поддержка Vue-Compat - это выполнимо. Хотя на данный момент планов реализации нет.

### 4. Почему не работает деструктуризация? Я понял, что могу исправить это, заключив всю компоненту в функцию.

Реактивность возникает при доступе к свойствам объектов Prop и Store. Ссылки на них вне привязки или реактивного вычисления отслеживаться не будут. Внутри них деструктуризация прекрасна.

Однако объединение всего вашего компонента в функцию - это не то, что вы хотите делать безответственно. Solid не имеет VDOM. Таким образом, любое отслеживаемое изменение приведет к повторному запуску всей функции, воссоздавая все заново. Не делайте этого.

### 5. Можете ли вы добавить поддержку класс-компонентов? Я считаю, что о жизненных циклах легче рассуждать.

Это не намерение Solid поддерживать класс-компоненты. Жизненные циклы Solid связаны с планированием реактивной системы и являются искусственными. Я полагаю, вы могли бы сделать из этого класс, но фактически весь код обработчика событий, не связанный с событиями, в основном запускается в конструкторе, включая функцию рендеринга. Это просто дополнительный синтаксис для предлога сделать ваши данные менее детализированными.

Группируйте данные и их поведение вместе, а не жизненные циклы. Это лучшая практика реактивности, работающая десятилетиями.

### 6. Мне действительно не нравится JSX, есть ли шанс на Template DSL? О, я вижу, у вас есть тегированные шаблонные литералы/HyperScript. Может, я воспользуюсь этими ...

Не надо. Остановись прямо здесь. Мы используем JSX так же, как Svelte использует свои шаблоны, для создания оптимизированных инструкций DOM. Решения тегированных шаблонных литералов и HyperScript могут быть действительно впечатляющими сами по себе, но, если у вас нет реальной причины, такой как требование отсутствия сборки, они уступают во всех отношениях. Пакеты большего размера, более низкая производительность и необходимость ручного обертывания значений.

Приятно иметь варианты, но Solid JSX - действительно лучшее решение. Шаблон DSL также был бы отличным, хотя и более ограничительным, но JSX дает нам так много всего бесплатно: Существующие синтаксические анализаторы, выделение синтаксиса, Prettier, многое другое и, наконец, TypeScript.

Другие библиотеки добавляли поддержку этих функций, но это потребовало огромных усилий и до сих пор все остается неидеальным и вызывает постоянную головную боль при обслуживании. Это действительно прагматическая позиция.

### 7. Когда использовать Signal, а когда Store? Почему они разные?

Магазины автоматически обертывают вложенные значения, что делает его идеальным для глубоких структур данных и таких вещей, как модели. Для большинства других вещей сигналы легковесны и прекрасно справляются со своей задачей.

Как бы нам ни хотелось объединить их в одно целое, но к сожалению, вы не можете проксировать примитивы. Функции - это самый простой интерфейс, и любое реактивное выражение (включая доступ к состоянию) может быть заключено в одно целое, что обеспечит универсальный API. Вы можете называть свои сигналы и состояние по своему усмотрению, и оно остается минимальным. Последнее, что мы хотели бы сделать, это принудительно ввести `.get ()` `.set ()` для конечного пользователя или, что еще хуже, `.value`. По крайней мере, первый может быть назван псевдонимом для краткости, тогда как последний - наименее краткий способ вызова функции.

### 8. Почему я не могу просто присвоить значение Store, как я могу это сделать в Vue. Svelte или MobX? Где двусторонняя привязка?

Реактивность - мощный, но опасный инструмент. MobX знает об этом и ввел строгий режим и действия, чтобы ограничить, где и когда происходят обновления. В Solid, который имеет дело со всеми деревьями данных Component, стало очевидно, что здесь мы можем кое-чему научиться у React. Вам не нужно быть фактически неизменным, если вы предоставляете средства для заключения одного и того же контракта.

Возможность передать способность обновлять состояние, возможно, даже более важна, чем решение передать состояние. Поэтому возможность разделить его, еще раз, очень важна, и это возможно только в том случае, если чтение неизменяемо. Нам также не нужно платить за неизменяемость, если мы все еще можем гранулярно обновлять. К счастью, между ImmutableJS и Immer есть масса примеров. По иронии судьба Solid действует в основном как обратный Immer со своими изменяемыми внутренностями и неизменяемым интерфейсом.

### 9. Могу ли я самостоятельно использовать реактивность Solid?

Конечно. Хотя мы не экспортировали отдельный пакет, Solid легко установить без компилятора и просто использовать реактивные примитивы. Одним из преимуществ гранулярной реактивности является то, что она не зависит от библиотеки. В этом отношении почти каждая реактивная библиотека работает таким образом. Это то, что вдохновило [Solid](https://github.com/solidjs/solid) и лежащую в его основе [библиотеку выражений DOM](https://github.com/ryansolid/dom-expressions) в первую очередь на создание рендерера чисто из реактивной системы.

Вот несколько примеров, которые стоит попробовать: [Solid](https://github.com/solidjs/solid), [MobX](https://github.com/mobxjs/mobx), [Knockout](https://github.com/knockout/knockout), [Svelte](https://github.com/sveltejs/svelte), [S.js](https://github.com/adamhaile/S), [CellX](https://github.com/Riim/cellx), [Derivable](https://github.com/ds300/derivablejs), [Sinuous](https://github.com/luwes/sinuous) и даже недавно [Vue](https://github.com/vuejs/vue). На создание реактивной библиотеки уходит гораздо больше, чем на ее добавление на какой-нибудь рендерер, например [lit-html](https://github.com/Polymer/lit-html), это хороший способ почувствовать о чем идет речь.

### 10. Есть ли у Solid библиотека типа Next.js или Material Components?

Насколько нам известно, нет. Если вы заинтересованы в его создании, мы легко доступны на нашем [Discord](https://discord.com/invite/solidjs), чтобы помочь в его создании. У нас уже есть основы, остается просто на них опираться.
