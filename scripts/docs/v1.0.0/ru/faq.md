---
title: Часто задаваемые вопросы
description: Ответы на часто задаваемые вопросы
sort: 2
---

# Часто задаваемые вопросы

### 1. JSX без VDOM? Это пароварка? Я слышал такие известные голоса, как авторы других фреймворков, которые говорят, что это невозможно.

Это возможно, когда у вас нет модели обновления React. JSX - это шаблонный DSL, как и любой другой. Просто тот, который в некоторых отношениях более гибкий. Иногда вставка произвольного JavaScript может быть сложной задачей, но ничем не отличается от поддержки операторов распространения. Так что нет, это не пароварка, а подход, который оказался одним из самых эффективных.

Настоящая выгода заключается в том, насколько она расширяема. У вас есть компилятор, работающий на вас, который дает вам оптимальные собственные обновления DOM, но у вас есть вся свобода библиотеки, такой как React, для написания компонентов с использованием таких методов, как Render Props и компоненты более высокого порядка, наряду с вашими реактивными хуками. Не нравится, как работает поток управления Solid? Напишите свой.

### 2. Почему Solid такой прозводительный?

Хотелось бы указать что-то одно, но на самом деле это комбинация многих важных дизайнерских решений:

1. Явная реактивность, поэтому отслеживаются только те вещи, которые должны быть реактивными.
2. Компилируйте с учетом первоначального создания. Solid использует эвристику, чтобы ослабить детализацию, чтобы уменьшить количество выполняемых вычислений, но сохранить ключевые обновления детализированными и производительными.
3. Реактивные выражения - это просто функции. Это позволяет использовать «исчезающие компоненты» с ленивой оценкой свойств. Удаляя ненужные оболочки и накладные расходы на синхронизацию.

В настоящее время эти уникальные методы в сочетании дают Solid преимущество над конкурентами.

### 3. Имеется ли React-Compat?

Нет. И, вероятно, никогда не будет. Хотя API-интерфейсы похожи, и компоненты часто можно перемещать с небольшими изменениями, модель обновления принципиально отличается. Компоненты React визуализируются снова и снова, поэтому код за пределами хуков работает совсем по-другому. Замыкания и правила хуков не только не нужны, их можно использовать способами, которые здесь не работают.

С другой стороны, поддержка Vue-Compat - это выполнимо. Хотя на данный момент планов реализации нет.

### 4. Почему не работает деструктуризация? Я понял, что могу исправить это, заключив весь свой компонент в функцию.

Реактивность возникает при доступе к свойствам объектов Prop и Store. Ссылки на них вне привязки или реактивного вычисления отслеживаться не будут. Внутри них деструктуризация прекрасна.

Однако объединение всего вашего компонента в функцию - это не то, что вы хотите делать безответственно. Solid не имеет VDOM. Таким образом, любое отслеживаемое изменение приведет к повторному запуску всей функции, воссоздавая все заново. Не делай этого.

### 5. Можете ли вы добавить поддержку класс-компонентов? Я считаю, что о жизненных циклах легче рассуждать.

Это не намерение поддерживать класс-компоненты. Жизненные циклы Solid связаны с планированием реактивной системы и являются искусственными. Я полагаю, вы могли бы сделать из этого класс, но фактически весь код обработчика событий, не связанный с событиями, в основном запускается в конструкторе, включая функцию рендеринга. Это просто дополнительный синтаксис для предлога сделать ваши данные менее детализированными.

Группируйте данные и их поведение вместе, а не жизненные циклы. Это лучшая практика реагирования, работающая десятилетиями.

### 6. Мне действительно не нравится JSX, есть ли шанс на Template DSL? О, я вижу, у вас есть тегированные шаблонные литералы / HyperScript. Может, я воспользуюсь этими ...

Не надо. Остановись прямо здесь. Мы используем JSX так же, как Svelte использует свои шаблоны, для создания оптимизированных инструкций DOM. Решения Tagged Template Literal и HyperScript могут быть действительно впечатляющими сами по себе, но, если у вас нет реальной причины, такой как требование отсутствия сборки, они уступают во всех отношениях. Пакеты большего размера, более низкая производительность и необходимость ручного обертывания значений обходного пути.

Приятно иметь варианты, но Solid JSX - действительно лучшее решение. Шаблон DSL также был бы отличным, хотя и более ограничительным, но JSX дает нам так много бесплатно. TypeScript, существующие синтаксические анализаторы, выделение синтаксиса, TypeScript, Prettier, завершение кода и, наконец, TypeScript.

Другие библиотеки добавляли поддержку этих функций, но это потребовало огромных усилий и все еще несовершенно и вызывает постоянную головную боль при обслуживании. Это действительно прагматическая позиция.

### 7. Когда использовать Signal, а когда Store? Почему они разные?

Магазины автоматически обертывают вложенные значения, что делает его идеальным для глубоких структур данных и таких вещей, как модели. Для большинства других вещей сигналы легковесны и прекрасно справляются со своей задачей.

Как бы нам ни хотелось объединить их в одно целое, но к сожалению, вы не можете проксировать примитивы. Функции - это самый простой интерфейс, и любое реактивное выражение (включая доступ к состоянию) может быть заключено в одно целое, что обеспечит универсальный API. Вы можете называть свои сигналы и состояние по своему усмотрению, и оно остается минимальным. Последнее, что мы хотели бы сделать, это принудительно ввести `.get ()` `.set ()` для конечного пользователя или, что еще хуже, `.value`. По крайней мере, первый может быть назван псевдонимом для краткости, тогда как последний - наименее краткий способ вызова функции.

### 8. Почему я не могу просто присвоить значение Solid's Store, как я могу это сделать в Vue. Svelte или MobX? Где двусторонняя привязка?

Реактивность - мощный, но опасный инструмент. MobX знает об этом и ввел строгий режим и действия, чтобы ограничить, где и когда происходят обновления. В Solid, который имеет дело со всеми деревьями данных Component, стало очевидно, что здесь мы можем кое-чему научиться у React. Вам не нужно быть фактически неизменным, если вы предоставляете средства для заключения одного и того же контракта.

Возможность передать возможность обновления состояния, возможно, даже важнее, чем принятие решения о передаче состояния. Так что возможность разделить это важно и возможно только в том случае, если чтение неизменяемо. Нам также не нужно платить за неизменность, если мы все еще можем детально обновлять. К счастью, между ImmutableJS и Immer есть масса предшествующего уровня техники. По иронии судьбы Solid действует в основном как обратный иммер с его изменяемыми внутренними компонентами и неизменяемым интерфейсом.

### 9. Могу ли я самостоятельно использовать реактивность Solid?

Конечно. Хотя мы не экспортировали отдельный пакет, Solid легко установить без компилятора и просто использовать реактивные примитивы. Одним из преимуществ гранулярной реактивности является то, что она не зависит от библиотеки. В этом отношении почти каждая реактивная библиотека работает таким образом. Это то, что вдохновило [Solid](https://github.com/solidjs/solid) и лежащую в его основе [библиотеки выражений DOM](https://github.com/ryansolid/dom-expressions) в первую очередь на создание рендерер чисто из реактивной системы.

Вот несколько примеров, которые стоит попробовать: [Solid](https://github.com/solidjs/solid), [MobX](https://github.com/mobxjs/mobx), [Knockout](https://github.com/knockout/knockout), [Svelte](https://github.com/sveltejs/svelte), [S.js](https://github.com/adamhaile/S), [CellX](https://github.com/Riim/cellx), [Derivable](https://github.com/ds300/derivablejs), [Sinuous](https://github.com/luwes/sinuous) и даже недавно [Vue ](https://github.com/vuejs/vue). На создание реактивной библиотеки уходит гораздо больше, чем на ее добавление в средство визуализации, например [lit-html](https://github.com/Polymer/lit-html), но это хороший способ почувствовать.

### 10. Есть ли у Solid библиотека типа Next.js или Material Components?

Насколько нам известно, нет. Если вы заинтересованы в его создании, мы легко доступны на нашем [Discord](https://discord.com/invite/solidjs), чтобы помочь в его создании. У нас уже есть основы, и нам просто нужно на них опираться.
