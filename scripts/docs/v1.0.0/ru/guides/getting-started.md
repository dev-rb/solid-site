---
title: Начать
description: Руководство по началу работы с Solid.
sort: 0
---

# Начать

## Попробовать Solid

Безусловно, самый простой способ начать работу с Solid - это попробовать его онлайн. [Наш REPL](https://playground.solidjs.com) - идеальный способ опробовать идеи. Как и [Sandbox](https://codesandbox.io/), где вы можете отредактировать любой из [наших примеров](https://github.com/solidjs/solid/blob/main/documentation/resources/examples.md).

Кроме того, вы можете использовать наши простые шаблоны [Vite](https://vitejs.dev/), выполнив следующие команды в своем терминале:

```sh
> npx degit solidjs/templates/js my-app
> cd my-app
> npm i #  yarn/pnpm
> npm run dev #  yarn/pnpm
```

Или с поддержкой TypeScript:

```sh
> npx degit solidjs/templates/ts my-app
> cd my-app
> npm i # yarn/pnpm
> npm run dev # yarn/pnpm
```

## Основы Solid

Solid состоит из маленьких частиц которые служат строительными блоками для приложений. Эти частицы в основном представляют из себя функции, составляющие поверхностные API слои. К счастью, для начала вам не нужно знать о большинстве из них для работы с Solid.

В вашем распоряжении есть два основных типа строительных блоков: компоненты и реактивные примитивы.

Компоненты - это функции, которые принимают `объект пропов` и возвращают `элементы JSX`, включая собственные элементы DOM и другие компоненты. В регистре паскаля (PascalCase) они могут быть выражены как элементы JSX:

```jsx
// Компонента
function MyComponent(props) {
  return <div>Привет {props.name}</div>;
}

<MyComponent name="Solid" />;
```

Компоненты легковесны, поскольку сами не имеют состояния и не имеют экземпляров. Вместо этого они служат фабричными функциями для элементов DOM и реактивных примитивов.

Реактивность Solid основана на 3 простых примитивах: Сигнал, Мемо и Эффект. Вместе они образуют механизм синхронизации с автоматическим отслеживанием, который обеспечивает обновленность вашего пользовательского интерфейса.

Реактивные вычисления принимают форму простых выражений с оберткой функций, которые выполняются синхронно.

```js
// Реактивные примитивы
const [a, setA] = createSignal(10);
const [b, setB] = createSignal(5);

// Эффект
createEffect(() => {
  const sum = a() + b();
  console.log(`${a()} + ${b()} = ${sum}`);
});
```

Вы можете узнать больше о [Solid Реактивность](#reactivity) и [Solid Рендеринг](#rendering).

## Философия Solid

Solid легче изучить и использовать, если вы знаете его философию.

В дизайне Solid есть несколько мнений о том, какие принципы и ценности помогут нам лучше всего создавать веб-сайты и приложения.

### 1. Декларативные данные

Декларативные данные - это практика привязки описания поведения данных к их объявлениям. Это позволяет легко упаковывать все аспекты поведения данных в одно место.

### 2. Исчезающие компоненты

Достаточно сложно структурировать компоненты без учета обновлений. Solid-обновления полностью независимы от компонентов. Компонентные функции вызываются один раз, а затем просто перестают существовать. Компоненты существуют для организации вашего кода и не более того.

### 3. Разделение чтения/записи

Точный контроль и предсказуемость делают системы лучше. Нам не нужна настоящая неизменность, чтобы обеспечить однонаправленный поток, нам просто нужна способность принимать осознанное решение.

### 4. Простой лучше легкого

Тяжелый урок для мелкозернистой реактивности. Наша цель состоит в том, чтобы предоставить минимальные инструменты, которые могли бы служить хорошим фундаментом. Кроме того, явные и последовательные соглашения, даже если они требуют дополнительных усилий, того стоят.

## Веб-компоненты

Solid родился с желанием иметь веб-компоненты как первоклассных граждан. Со временем его конструкция и цели изменились. Однако Solid по-прежнему остается отличным способом создания веб-компонентов. [Solid-элемент](https://github.com/solidjs/solid/tree/main/packages/solid-element) позволяет писать и оборачивать функциональные компоненты Solid для создания небольших и производительных веб-компонентов. В Solid-приложениях Solid-элемент может по-прежнему использовать Solid Context API, а порталы Solid поддерживают Shadow DOM для добавления изолированных стилей.

## Рендеринг на стороне сервера

Solid предлагает решение для динамического рендеринга на стороне сервера, которое обеспечивает поистине изоморфный опыт разработки. Благодаря использованию нашего примитива ресурсов асинхронные запросы данных легко выполняются и, что более важно, автоматически стерилизуются и синхронизируются между клиентом и браузером.

Поскольку Solid поддерживает асинхронный и потоковый рендеринг на сервере, вы можете писать код в одном направлении и запускать его на сервере. Это означает, что такие функции, как [render-as-you-fetch](https://reactjs.org/docs/concurrent-mode-suspense.html#approach-3-render-as-you-fetch-using-suspense) и разделение кода буду работать без проблем.

Для получения дополнительной информации прочтите [Рендеринг на стороне сервера](#server-side-rendering).

## Нет компиляции?

Не любите JSX? Не возражаете ручной работе обертки выражений, худшей производительности и больших размеров файлов? В качестве альтернативы вы можете использовать тегированные шаблонные литералы или HyperScript в средах без возможности использования компилятора.

Запускать их можно прямо из браузера, используя [Skypack](https://www.skypack.dev/):

```html
<html>
  <body>
    <script type="module">
      import {
        createSignal,
        onCleanup,
      } from "https://cdn.skypack.dev/solid-js";
      import { render } from "https://cdn.skypack.dev/solid-js/web";
      import html from "https://cdn.skypack.dev/solid-js/html";

      function App() {
        const [count, setCount] = createSignal(0);
        const timer = setInterval(() => setCount(count() + 1), 1000);

        onCleanup(() => clearInterval(timer));
        return html`<div>${count}</div>`;
      }

      render(App, document.body);
    </script>
  </body>
</html>
```

Помните, что вам все еще нужна соответствующая библиотека выражений DOM для их работы с TypeScript. Вы можете использовать тегированные шаблонные литералы с [Lit DOM Выражениями](https://github.com/ryansolid/dom-expressions/tree/main/packages/lit-dom-expressions) или HyperScript с [Hyper DOM Выражениями](https://github.com/ryansoliddom-expressions/tree/main/packages/hyper-dom-expressions).
