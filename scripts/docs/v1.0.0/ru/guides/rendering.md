---
title: Рендеринг
description: Различные варианты создания шаблонов и рендеринга в Solid.
sort: 2
---

# Рендеринг

Solid поддерживает создание шаблонов в трех формах: `JSX`, теговые шаблонные литералы и вариант Solid `HyperScript`, хотя JSX является преобладающей формой.

Почему JSX - отличный DSL для компиляции? Он имеет четкий синтаксис, поддерживает TypeScript, работает с Babel и поддерживает другие инструменты, такие как подсветка кода и Prettier. Было бы глупо не использовать инструмент, который, по сути, дает нам все это бесплатно. В качестве скомпилированного решения он обеспечивает отличный DX. Зачем бороться с настраиваемыми синтаксическими DSL, если вы можете использовать так широко поддерживаемый?

## Компиляция JSX

Рендеринг включает в себя предварительную компиляцию шаблонов JSX в оптимизированный нативный JS код. Код JSX строит:

- Шаблонные элементы DOM, которые клонируются при каждом создании экземпляра.
- Серия ссылочных деклараций с использованием только firstChild и nextSibling
- Вычисления для обновления элементов.

Этот подход является более производительным и создает меньше кода, чем создание каждого элемента один за другим с помощью `document.createElement`.

## Атрибуты и `Пропсы`

Solid старается максимально отразить соглашения HTML, включая нечувствительность к регистру атрибутов.

Большинство атрибутов в элементах DOM выглядят так же в нашем JSX. Статические значения встроены прямо в клонируемый шаблон. Есть ряд исключений, таких как `class`, `style`, `value`, `innerHTML`, которые обеспечивают дополнительную функциональность.

Однако [пользовательские элементы](https://developer.mozilla.org/ru/docs/Web/Web_Components#%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D0%BA%D0%B8%D0%B5_%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D1%8B) (за исключением встроенных модулей) по умолчанию принимают `пропсы`. Это необходимо для обработки более сложных типов данных. Он выполняет это преобразование с помощью стандартных имен атрибутов в `snake-case`, например `some-attr` в `someAttr`.

Мы можем управлять этим поведением напрямую с помощью `директив`. Вы можете принудительно использовать атрибут с помощью `attr:`или prop с `prop:`

```jsx
<my-element prop:UniqACC={state.value} attr:title={state.title} />
```

> **Заметка:** Статические атрибуты создаются как часть клонируемого шаблона html. Зафиксированные и динамические выражения применяются впоследствии в порядке привязки JSX. Хотя это нормально для большинства элементов DOM, есть некоторые, например элементы ввода с `type='range'`, где порядок имеет значение. Помните об этом при связывании элементов.

## Главный компонент

Самый простой способ встроить Solid в DOM это - импортировать рендер из `solid-js/web`. `render` принимает функцию в качестве первого аргумента и контейнер для встраивания в качестве второго и возвращает метод удаления. Этот рендеринг автоматически создает реактивный корень и обрабатывает рендеринг. Для лучшей производительности используйте элемент без внутренних элементов.

```jsx
import { render } from 'solid-js/web'

render(() => <App />, document.getElementById('main'))
```

> **Важно** Первый аргумент должен быть функцией. В противном случае мы не сможем должным образом отслеживать и планировать работу реактивной системы. Это простое упущение приведет к тому, что ваши эффекты не будут работать.

## Компоненты

Компоненты в Solid - это просто функции в регистре паскаля(PascalCase). Их первый аргумент - это `объект props`. Компоненты возвращают реальные узлы DOM.

```jsx
const Parent = () => (
  <section>
    <Label greeting='Hello'>
      <div>Джон</div>
    </Label>
  </section>
)

const Label = props => (
  <>
    <div>{props.greeting}</div>
    {props.children}
  </>
)
```

Поскольку все узлы JSX являются фактическими узлами DOM, единственная обязанность компонентов вашего компонента - добавить их в DOM.

## `Пропсы`

Подобно React, Vue, Angular и другим фреймворкам, Solid позволяет вам определять свойства ваших компонентов для передачи данных дочерним компонентам. Здесь родитель передает строку «Hello» компоненту `Label` через свойство `greeting`.

```jsx
const Parent = () => (
  <section>
    <Label greeting='Hello'>
      <div>John</div>
    </Label>
  </section>
)
```

В приведенном выше примере значение, установленное для `greeting`, является статическим, но мы также можем установить динамические значения:

```jsx
const Parent = () => {
  const [greeting, setGreeting] = createSignal('Hello')

  return (
    <section>
      <Label greeting={greeting()}>
        <div>John</div>
      </Label>
    </section>
  )
}
```

Компоненты могут получить доступ к свойствам, переданным им через аргумент `props`.

```jsx
const Label = props => (
  <>
    <div>{props.greeting}</div>
    {props.children}
  </>
)
```

В отличие от некоторых других фреймворков, вы не можете использовать деструктуризацию объекта в свойствах компонента. Это связано с тем, что объект `props` за кулисами полагается на геттеры объекта для ленивого извлечения значений. Использование деструктурирования объекта нарушает реактивность `props`.

В этом примере показан «правильный» способ доступа к пропсам в Solid:

```jsx
// Здесь `props.name` обновится
const MyComponent = props => <div>{props.name}</div>
```

В этом примере показан неправильный способ доступа к реквизитам в Solid:

```jsx
// Здесь `props.name` не будет обновляться (т.е. не будет реагировать), так как он деструктурирован в `name`
const MyComponent = ({ name }) => <div>{name}</div>
```

Хотя объект props выглядит как обычный объект, когда вы его используете (и пользователи Typescript заметят, что он типирован как обычный объект), на самом деле он является реактивным - чем-то похожим на Signal. Это имеет несколько значений.

Поскольку в отличие от большинства фреймворков JSX, функциональные компоненты Solid выполняются только один раз (а не каждый цикл рендеринга), следующий пример не будет работать как ожидалось.

```jsx
import { createSignal } from 'solid-js'

const BasicComponent = props => {
  const value = props.value || 'default'

  return <div>{value}</div>
}

export default function Form() {
  const [value, setValue] = createSignal('')

  return (
    <div>
      <BasicComponent value={value()} />
      <input type='text' oninput={e => setValue(e.currentTarget.value)} />
    </div>
  )
}
```

В этом примере мы, вероятно, хотим, чтобы `BasicComponent` отображал текущее значение, введенное в `input`. Но, напоминаем вам, что функция `BasicComponent` будет выполняться только один раз при первоначальном создании компонента. В это время (при создании) props.value будет равняться пустой строке. Это означает, что `value` в BasicComponent будет преобразовано в значение `default` и никогда не будет обновляться. Пока объект `props` является реактивным, доступ к свойствам в `const value = props.value || 'default';` находится за пределами наблюдаемой области Solid, поэтому он не переоценивается автоматически при изменении свойств.

Итак, как мы можем решить нашу проблему?

Ну, в общем, нам нужно получить доступ к `props` где-нибудь, чтобы Solid мог его наблюдать. Обычно это означает внутри JSX или внутри `createMemo`,`createEffect`. Вот одно из решений, которое работает должным образом:

```jsx
const BasicComponent = props => {
  return <div>{props.value || 'default'}</div>
}
```

Пример выше эквивалентен этому:

```jsx
const BasicComponent = props => {
  const value = () => props.value || 'default'
  return <div>{value()}</div>
}
```

Другой вариант, если это дорогостоящее вычисление, - использовать `createMemo`:

```jsx
const BasicComponent = props => {
  const value = createMemo(() => props.value || 'default')

  return <div>{value()}</div>
}
```

Или с помощью помощника:

```jsx
const BasicComponent = props => {
  props = mergeProps({ value: 'default' }, props)

  return <div>{props.value}</div>
}
```

Напоминаем, что следующие примеры работать **не будут**:

```jsx
// Плохо
const BasicComponent = props => {
  const { value: valueProp } = props
  const value = createMemo(() => valueProp || 'default')
  return <div>{value()}</div>
}

// Плохо
const BasicComponent = props => {
  const valueProp = prop.value
  const value = createMemo(() => valueProp || 'default')
  return <div>{value()}</div>
}
```

Компоненты Solid являются ключевой частью его производительности. Подход Solid к "исчезающим" компонентам стал возможен благодаря ленивой (`lazy`) загрузке свойств. Вместо того, чтобы немедленно оценивать выражения опоры и передавать значения, выполнение откладывается до тех пор, пока опора не будет доступна в дочернем элементе. Поступая таким образом, мы откладываем выполнение до последнего момента, обычно прямо в привязках DOM, что увеличивает производительность. Это сглаживает иерархию и устраняет необходимость поддерживать дерево компонентов.

```jsx
;<Component prop1='static' prop2={state.dynamic} />

// Компилируется примерно в:
untrack(() =>
// Мы отследим тело компонента, чтобы изолировать его и предотвратить дорогостоящие обновления
  Component({
    prop1: 'static',
    // Это динамическое выражение, мы оборачиваем его геттером
    get prop2() {
      return state.dynamic
    },
  }),
)
```

Чтобы поддерживать реактивность, Solid имеет несколько помощников:

```jsx
// Пропсы c значением по умолчанию
props = mergeProps({ name: "Smith" }, props);

// Клонирование пропсов
const newProps = mergeProps(props);

// Слияние пропсов
props = mergeProps(props, otherProps);

// Разделить пропсы на несколько объектов-пропсов
const [local, others] = splitProps(props, ["className"])
<div {...others} className={cx(local.className, theme.component)} />
```

## Дочерние элементы

Solid обрабатывает дочерние элементы JSX аналогично React. Один дочерний элемент - это одно значение в props.children, а несколько дочерних элементов обрабатываются через массив значений. Обычно вы передаете их в представление JSX. Однако, если вы хотите взаимодействовать с ними, используйте помощник `children`, который разрешает любые последующие потоки управления и вернет Memo.

```jsx
// Единственный дочерний элемент
const Label = (props) => <div class="label">Hi, { props.children }</div>

<Label><span>Josie</span></Label>

// Несколько дочерних элементов
const List = (props) => <div>{props.children}</div>;

<List>
  <div>First</div>
  {state.expression}
  <Label>Judith</Label>
</List>

// Пройтись по дочерним элементам
const List = (props) => <ul>
  <For each={props.children}>{item => <li>{item}</li>}</For>
</ul>;

// Пройтись по дочерним элементами и модифицировать их с помощью помощника
const List = (props) => {
  // Помощник `children` запоминает значение и поддерживает промежуточную реактивность
  const memo = children(() => props.children);

  createEffect(() => {
    const children = memo();
    children.forEach((c) => c.classList.add("list-child"))
  })

  return <ul>
    <For each={memo()}>{item => <li>{item}</li>}</For>
  </ul>;
```

> **Важно:** Solid обрабатывает дочерние теги как дорогостоящие выражения и оборачивает их как динамические реактивные выражения. Это означает, что они лениво оценивают доступ к `prop`. Будьте осторожны, обращаясь к ним несколько раз или деструктурируя перед тем, как использовать их в представлении. Это связано с тем, что Solid не имеет возможности заранее создавать узлы Virtual DOM, а затем их сравнивать, поэтому вычисление значения этих `props` должно быть ленивым и преднамеренным. Используйте помощник `children`, если хотите, чтобы он запомнил их.
