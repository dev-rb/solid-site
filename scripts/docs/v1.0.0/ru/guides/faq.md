---
title: Часто задаваемые вопросы
description: Ответы на часто задаваемые вопросы
sort: 5
---

# Часто задаваемые вопросы

### 1. JSX без VDOM? Это что, вейпорвейв? Я слышал, что это невозможно от авторов других фреймворков.

Это возможно, когда у вас нет модели обновления React. JSX - это всего лишь шаблонный DSL, как и любой другой. Просто в некоторых моментах более гибкий. Анализ произвольного JavaScript кода может быть сложной задачей, но ничем не отличается от поддержки spread-операторов. Так что нет, это не вейпорвейв, а подход, который оказался одним из самых эффективных.

Главным плюсом JSX заключается в его расширяемости. Мы создали компилятор, работающий на вас, который даст вам оптимальные обновления DOM. Вы спросите: есть ли у этого своя цена? Если не считать различия в том, как работают реактивные примитивы, то скорее всего нет! Вы можете писать многие компоненты так же, как вы писали их в React, например, используя подходы вроде [рендер-пропсов](https://ru.reactjs.org/docs/render-props.html) или [компонентов высшего порядка](https://ru.reactjs.org/docs/higher-order-components.html), наряду с вашими реактивными хуками. Не нравится, как работает поток управления Solid? Вы можете написать свой!

### 2. Почему Solid такой производительный?

Так хотелось бы указать что-то одно, но на самом деле это комбинация многих решений дизайна:

1. Явная реактивность. Отслеживаются только те вещи, которые должны быть реактивными.
2. Компиляция с учетом первоначального создания. Solid использует эвристику, чтобы уменьшить количество выполняемых вычислений, но сохранить ключевые обновления детализированными и производительными.
3. Реактивные выражения - это просто функции. Это позволяет использовать «исчезающие компоненты» с ленивой оценкой свойств. Удаляя ненужные оболочки и накладные расходы на синхронизацию.

В настоящее время эти уникальные методы в сочетании дают Solid преимущество над конкурентами.

### 3. Существует ли React-Compat?

Нет. И, вероятно, никогда не будет существовать. Хотя API-интерфейсы похожи, и компоненты часто можно перемещать с небольшими изменениями, модель обновления принципиально отличается. Компоненты React визуализируются снова и снова, поэтому код за пределами хуков работает совсем по-другому. Замыкания и правила хуков не только не нужны, их можно использовать способами, которые здесь не работают.

В будущем вполне возможна, например, поддержка Vue-Compat, хотя на данный момент планов реализации нет.

### 4. Почему не работает деструктуризация? Я понял, что могу исправить это, заключив весь компонент в функцию.

Реактивность возникает при доступе к свойствам объектов Prop и Store. Вы можете использовать деструктуризацию внутри привязки (`binding`) или реактивного вычисления (`reactive computation`), но при использовании деструктуризации вне этих контекстов вы потеряете отслеживание. 

Однако объединение всего вашего компонента в функцию - это не то, что вы хотите делать безответственно. Solid не имеет VDOM. Таким образом, любое отслеживаемое изменение приведет к повторному запуску всей функции, пересоздавая все заново. Не делайте этого.

### 5. Можете ли вы добавить поддержку классовых компонентов? Я считаю, что о жизненных циклах легче рассуждать.

Solid не имеет намерения поддерживать классовые компоненты. Жизненные циклы Solid связаны с планированием реактивной системы и являются искусственными. Я полагаю, вы могли бы сделать из этого класс, но фактически весь код обработчика событий, не связанный с событиями, в основном запускается в конструкторе, включая функцию рендеринга. Это просто дополнительный синтаксис для предлога сделать ваши данные менее детализированными.

Группируйте данные и их поведение, вместо того, чтобы группировать жизненные циклы. Это лучшая практика реактивности, зарекомендовавшая себя десятилетиями опыта.

### 6. Мне действительно не нравится JSX, есть ли шанс на Template DSL? О, я вижу, у вас есть теговые шаблонные литералы/HyperScript. Может, я воспользуюсь этими ...

Если у вас нет особой причины этого делать, то мы рекомендуем остановиться и задуматься. Мы используем JSX так же, как Svelte использует свои шаблоны, для создания оптимизированных инструкций DOM. Решения вроде [теговых шаблонных литералов](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Template_literals#%D1%82%D0%B5%D0%B3%D0%BE%D0%B2%D1%8B%D0%B5_%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B_%D0%B8_%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%BE%D0%B2) и HyperScript могут быть действительно впечатляющими сами по себе, но, если у вас нет специфических требований, например необходимость избавиться от сборки (`bundling`), то мы советуем использовать JSX. Иначе вы получите больше JS в вашем бандле (`bundle`), более низкую производительность и необходимость ручной обертки значений.

Приятно иметь варианты, но Solid JSX - действительно лучшее решение. Шаблон DSL также был бы отличным, но у него есть свои ограничения, которые мы получаем JSX совершенно бесплатно: существующие анализаторы кода, подсветка синтаксиса, Prettier, TypeScript и ещё много всего.

Другие библиотеки добавляли поддержку этих функций, но это потребовало огромных усилий и до сих пор все остается неидеальным и вызывает постоянную головную боль при обслуживании. Выбор JSX это ничто иное, как прагматическая позиция.

### 7. Когда использовать Signal, а когда Store? Почему они разные?

`Сторы` автоматически оборачивают вложенные значения, что делает его идеальным для сложных структур данных и таких вещей, как модели. Для большинства других вещей `Сигналы` легковесны и прекрасно справляются со своей задачей.

Как бы нам ни хотелось объединить их в одно целое, но к сожалению, вы не можете проксировать примитивы. Функции - это самый простой интерфейс, и любое реактивное выражение (включая доступ к состоянию) может быть заключено в одно целое, что обеспечит универсальный API. Вы можете называть свои `Сигналы` и состояние по своему усмотрению, и оно остается минимальным. Последнее, что мы хотели бы сделать, это принудительно ввести `.get()` `.set()` для конечного пользователя или, что еще хуже, `.value`. По крайней мере, первый может быть назван псевдонимом для краткости, тогда как последний - наименее краткий способ вызова функции.

### 8. Почему я не могу просто присвоить значение Store, как я могу это сделать в Vue. Svelte или MobX? Где двусторонняя привязка?

Реактивность - мощный, но опасный инструмент. MobX знает об этом и ввел строгий режим и действия, чтобы ограничить, где и когда происходят обновления. В Solid, который имеет дело со всеми деревьями данных в компонентах, стало очевидно, что здесь мы можем кое-чему научиться у React. Вам не нужно быть фактически неизменным (`immutable`), если вы предоставляете средства для заключения одного и того же контракта.

Возможность обновить состояние, возможно, даже более важна, чем решение передать это состояние. Поэтому возможность разделить его, еще раз, очень важна, и это возможно только в том случае, если чтение неизменяемо. Нам также не нужно платить за неизменяемость, если мы все еще можем гранулярно обновлять. К счастью, у нас есть много подобных примеров в виде `ImmutableJS` и `Immer`. По иронии судьбы Solid представляет из себя перевернутую модель `Immer` со своими изменяемыми внутренностями и неизменяемым интерфейсом.

### 9. Могу ли я самостоятельно использовать реактивность Solid?

Конечно. Хотя мы не публиковали систему реактивности отдельно, Solid легко установить без компилятора и просто использовать реактивные примитивы. Одним из преимуществ гранулярной реактивности является то, что она не зависит от библиотеки. В этом отношении почти каждая реактивная библиотека работает таким образом. Это то, что вдохновило [Solid](https://github.com/solidjs/solid) и лежащую в его основе [библиотеку выражений DOM](https://github.com/ryansolid/dom-expressions) в первую очередь на создание рендерера чисто из реактивной системы.

Вот несколько примеров, которые стоит попробовать: [Solid](https://github.com/solidjs/solid), [MobX](https://github.com/mobxjs/mobx), [Knockout](https://github.com/knockout/knockout), [Svelte](https://github.com/sveltejs/svelte), [S.js](https://github.com/adamhaile/S), [CellX](https://github.com/Riim/cellx), [Derivable](https://github.com/ds300/derivablejs), [Sinuous](https://github.com/luwes/sinuous) и даже недавно [Vue](https://github.com/vuejs/vue). На создание реактивной библиотеки уходит гораздо больше, чем на ее добавление на какой-нибудь рендерер, например [lit-html](https://github.com/Polymer/lit-html), это хороший способ почувствовать о чем идет речь.

### 10. Есть ли у Solid библиотека типа Next.js или Material Components?

Насколько нам известно, нет. Если вы заинтересованы в его создании, мы легко доступны на нашем [Discord](https://discord.com/invite/solidjs), чтобы помочь в его создании. У нас есть всё что необходимо для создания потрясающей экосистемы!
