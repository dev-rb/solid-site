---
title: Реактивность
description: Полный обзор реактивности Solid.
sort: 1
---

# Реактивность

Управление данными Solid построено на наборе гибких реактивных примитивов, которые отвечают за все обновления. Solid использует подход, очень похожий на MobX или Vue, за исключением того, что он никогда не меняет свою гранулярность на VDOM. Зависимости автоматически отслеживаются, когда вы обращаетесь к своим реактивным значениям в коде эффектов и JSX.

Примитивы Solid представлены в виде вызовов `create...`, которые часто возвращают кортежи, где обычно первый элемент является читаемым примитивом(геттер), а второй - установщиком(сеттер). Обычно именем примитива называют только читаемую часть.

Вот базовый счетчик с автоматическим приращением, который обновляется в зависимости от установки сигнала `count`.

```jsx
import { createSignal, onCleanup } from "solid-js";
import { render } from "solid-js/web";

function App() {
    const [count, setCount] = createSignal(0);

    const timer = setInterval(() => {
        setCount(count() + 1);
    }, 1000);

    onCleanup(() => clearInterval(timer));

    return <div>{count()}</div>;
}

render(() => <App />, document.getElementById("app"));
```

## Введение в примитивы

Solid состоит из 3 основных примитивов: `Сигнал`, `Мемо` и `Эффект`. В их основе лежит паттерн наблюдателя, в котором Сигналы (и Мемо) отслеживаются путем обертывания их в те же Мемо и Эффекты.

Сигналы - простейшие примитивы. Они содержат одно значение, а также функции получения и установки, чтобы мы знали, когда они читаются и записываются.

```js
const [count, setCount] = createSignal(0);
```

Эффекты - это функции, которые оборачивают нашы сигналы и повторно вызывают функцию внутри при изменении значения зависимого сигнала. Это полезно для создания побочных эффектов, таких как рендеринг.

```js
createEffect(() => console.log("Последнее значение счетчика", count()));
```

Наконец, Мемо - это кэшированные производные значения. Они имеют свойства как сигналов, так и эффектов. Они отслеживают свои собственные зависимые сигналы, повторно выполняясь только при их изменении, а так же сами являются отслеживаемыми сигналами.

```js
const fullName = createMemo(() => `${firstName()} ${lastName()}`);
```

## Прицип работы

Сигналы - это источники событий, которые содержат список подписок. Они уведомляют своих подписчиков всякий раз, когда их стоимость меняется.

Что еще интереснее, так это то, как это происходит. Solid использует автоматическое отслеживание зависимостей. Обновления происходят автоматически по мере изменения данных.

Уловка заключается в глобальном стеке во время выполнения. Прежде чем Эффект или Мемо выполнит (или повторно выполнит) свою функцию, предоставленную разработчиком, помещается в этот стек. Затем любой прочитанный сигнал проверяет, есть ли текущий слушатель в стеке, и, если да, добавляет слушателя в свои подписки.

Вы можете думать об этом так:

```js
function createSignal(value) {
    const subscribers = new Set();

    function read() {
        const listener = getCurrentListener();
        if (listener) subscribers.add(listener);
        return value;
    }

    function write() {
        value = nextValue;
        for (const sub of subscribers) sub.run();
    }

    return [read, write];
}
```

Теперь всякий раз, когда мы обновляем сигнал, мы знаем, какие эффекты нужно запустить повторно. Просто, но эффективно. Фактическая реализация намного сложнее, но это внутренняя часть того, что происходит.

Для более подробного понимания того, как работает реактивность, можно прочитать следующие полезные статьи:

[Практическое введение в реактивность](https://dev.to/ryansolid/a-hands-on-introduction-to-fine-grained-reactivity-3ndf)

[Создание реактивной библиотеки с нуля](https://dev.to/ryansolid/building-a-reactive-library-from-scratch-1i0p)

[От рективности до рендеринга](https://indepth.dev/posts/1289/solidjs-reactivity-to-rendering)

## Соображения

Такой подход к реактивности очень мощный и динамичный. Он может обрабатывать зависимости на лету, посредством выполнения различных ветвей условного кода. Данный подход также работает на многих уровнях косвенного обращения. Также отслеживается любая функция, выполняемая внутри области отслеживания.

Однако есть некоторые ключевые особенности поведения и компромиссы, о которых мы должны знать.

1. Вся реактивность отслеживается из вызовов функций, впрямую или из функций скрытых под каким-либо геттером/прокси и запускается реактивность при доступе к свойству. Это означает, важно понимать откуда вы получаете доступ к свойствам реактивных объектов.

2. Компоненты и обратные вызовы из потоков управления не отслеживают области видимости и выполняются только один раз. Это означает, что деструктуризация или выполнение логики верхнего уровня в ваших компонентах не будет выполняться повторно. Доступ к этим сигналам, сторам и пропам должен быть осуществлен внутри других реактивных примитивов или JSX, чтобы эта часть кода могла быть повторно оценена.

3. В данном подходе отслеживание идет только синхронно. Если у вас есть setTimeout или же вы используете асинхрную функцию в своем createEffect, код, который будет выполняться асинхронно, не будет отслеживаться.
