{
  "sections": [
    {
      "slug": "%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB",
      "title": "はじめに",
      "level": 1,
      "children": [
        {
          "slug": "solid-%E3%82%92%E8%A9%A6%E3%81%99",
          "title": "Solid を試す",
          "level": 2,
          "children": []
        },
        {
          "slug": "solid-%E3%82%92%E5%AD%A6%E3%81%B6",
          "title": "Solid を学ぶ",
          "level": 2,
          "children": []
        },
        {
          "slug": "solid-%E3%81%AB%E8%80%83%E3%81%88%E3%82%8B",
          "title": "Solid に考える",
          "level": 2,
          "children": [
            {
              "slug": "1.-%E5%AE%A3%E8%A8%80%E5%9E%8B%E3%83%87%E3%83%BC%E3%82%BF",
              "title": "1. 宣言型データ",
              "level": 3,
              "children": []
            },
            {
              "slug": "2.-%E6%B6%88%E3%81%88%E3%82%8B%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88",
              "title": "2. 消えるコンポーネント",
              "level": 3,
              "children": []
            },
            {
              "slug": "3.-%E3%83%AA%E3%83%BC%E3%83%89%2F%E3%83%A9%E3%82%A4%E3%83%88%E3%81%AE%E5%88%86%E9%9B%A2",
              "title": "3. リード/ライトの分離",
              "level": 3,
              "children": []
            },
            {
              "slug": "4.-%E3%82%B7%E3%83%B3%E3%83%97%E3%83%AB%E3%81%AF%E3%82%A4%E3%83%BC%E3%82%B8%E3%83%BC%E3%81%AB%E5%8B%9D%E3%82%8B",
              "title": "4. シンプルはイージーに勝る",
              "level": 3,
              "children": []
            }
          ]
        },
        {
          "slug": "web-%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88",
          "title": "Web コンポーネント",
          "level": 2,
          "children": []
        },
        {
          "slug": "%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0",
          "title": "サーバーレンダリング",
          "level": 2,
          "children": []
        },
        {
          "slug": "%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E3%81%AA%E3%81%97%EF%BC%9F",
          "title": "コンパイルなし？",
          "level": 2,
          "children": []
        }
      ]
    },
    {
      "slug": "%E3%83%AA%E3%82%A2%E3%82%AF%E3%83%86%E3%82%A3%E3%83%93%E3%83%86%E3%82%A3",
      "title": "リアクティビティ",
      "level": 1,
      "children": [
        {
          "slug": "%E3%83%97%E3%83%AA%E3%83%9F%E3%83%86%E3%82%A3%E3%83%96%E3%81%AE%E7%B4%B9%E4%BB%8B",
          "title": "プリミティブの紹介",
          "level": 2,
          "children": []
        },
        {
          "slug": "%E5%8B%95%E4%BD%9C%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF",
          "title": "動作の仕組み",
          "level": 2,
          "children": []
        },
        {
          "slug": "%E8%80%83%E6%85%AE%E3%81%99%E3%81%B9%E3%81%8D%E7%82%B9",
          "title": "考慮すべき点",
          "level": 2,
          "children": []
        }
      ]
    },
    {
      "slug": "%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0",
      "title": "レンダリング",
      "level": 1,
      "children": [
        {
          "slug": "jsx-%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB",
          "title": "JSX コンパイル",
          "level": 2,
          "children": []
        },
        {
          "slug": "%E5%B1%9E%E6%80%A7%E3%81%A8%E3%83%97%E3%83%AD%E3%83%91%E3%83%86%E3%82%A3",
          "title": "属性とプロパティ",
          "level": 2,
          "children": []
        },
        {
          "slug": "%E3%82%A8%E3%83%B3%E3%83%88%E3%83%AA%E3%83%BC",
          "title": "エントリー",
          "level": 2,
          "children": []
        },
        {
          "slug": "%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88",
          "title": "コンポーネント",
          "level": 2,
          "children": []
        },
        {
          "slug": "props",
          "title": "Props",
          "level": 2,
          "children": []
        },
        {
          "slug": "children",
          "title": "Children",
          "level": 2,
          "children": []
        }
      ]
    },
    {
      "slug": "%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%82%B5%E3%82%A4%E3%83%89%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0",
      "title": "サーバーサイドレンダリング",
      "level": 1,
      "children": [
        {
          "slug": "%E3%83%8F%E3%82%A4%E3%83%89%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88",
          "title": "ハイドレーションスクリプト",
          "level": 2,
          "children": []
        },
        {
          "slug": "%E9%9D%9E%E5%90%8C%E6%9C%9F%E3%81%8A%E3%82%88%E3%81%B3%E3%82%B9%E3%83%88%E3%83%AA%E3%83%BC%E3%83%9F%E3%83%B3%E3%82%B0-ssr",
          "title": "非同期およびストリーミング SSR",
          "level": 2,
          "children": []
        },
        {
          "slug": "ssr-%E3%81%AE%E6%B3%A8%E6%84%8F%E7%82%B9",
          "title": "SSR の注意点",
          "level": 2,
          "children": []
        },
        {
          "slug": "ssr-%E3%82%92%E5%A7%8B%E3%82%81%E3%82%8B",
          "title": "SSR を始める",
          "level": 2,
          "children": []
        },
        {
          "slug": "%E9%9D%99%E7%9A%84%E3%82%B5%E3%82%A4%E3%83%88%E7%94%9F%E6%88%90%E3%82%92%E5%A7%8B%E3%82%81%E3%82%8B",
          "title": "静的サイト生成を始める",
          "level": 2,
          "children": []
        }
      ]
    },
    {
      "slug": "%E4%BB%96%E3%81%AE%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%81%A8%E3%81%AE%E6%AF%94%E8%BC%83",
      "title": "他のライブラリとの比較",
      "level": 1,
      "children": [
        {
          "slug": "react",
          "title": "React",
          "level": 2,
          "children": [
            {
              "slug": "%E7%A7%BB%E8%A1%8C%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%82%A2%E3%83%89%E3%83%90%E3%82%A4%E3%82%B9%3A",
              "title": "移行のためのアドバイス:",
              "level": 4,
              "children": []
            }
          ]
        },
        {
          "slug": "vue",
          "title": "Vue",
          "level": 2,
          "children": [
            {
              "slug": "%E7%A7%BB%E8%A1%8C%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%82%A2%E3%83%89%E3%83%90%E3%82%A4%E3%82%B9%3A-1",
              "title": "移行のためのアドバイス:",
              "level": 4,
              "children": []
            }
          ]
        },
        {
          "slug": "svelte",
          "title": "Svelte",
          "level": 2,
          "children": [
            {
              "slug": "%E7%A7%BB%E8%A1%8C%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%82%A2%E3%83%89%E3%83%90%E3%82%A4%E3%82%B9%3A-2",
              "title": "移行のためのアドバイス:",
              "level": 4,
              "children": []
            }
          ]
        },
        {
          "slug": "knockout.js",
          "title": "Knockout.js",
          "level": 2,
          "children": [
            {
              "slug": "%E7%A7%BB%E8%A1%8C%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%82%A2%E3%83%89%E3%83%90%E3%82%A4%E3%82%B9%3A-3",
              "title": "移行のためのアドバイス:",
              "level": 4,
              "children": []
            }
          ]
        },
        {
          "slug": "lit-%26-lighterhtml",
          "title": "Lit & LighterHTML",
          "level": 2,
          "children": [
            {
              "slug": "%E7%A7%BB%E8%A1%8C%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%82%A2%E3%83%89%E3%83%90%E3%82%A4%E3%82%B9%3A-4",
              "title": "移行のためのアドバイス:",
              "level": 4,
              "children": []
            }
          ]
        },
        {
          "slug": "s.js",
          "title": "S.js",
          "level": 2,
          "children": []
        },
        {
          "slug": "rxjs",
          "title": "RxJS",
          "level": 2,
          "children": []
        },
        {
          "slug": "%E3%81%9D%E3%81%AE%E4%BB%96",
          "title": "その他",
          "level": 2,
          "children": []
        }
      ]
    },
    {
      "slug": "faq",
      "title": "FAQ",
      "level": 1,
      "children": []
    }
  ],
  "content": "<section class=\"mt-10\"><h1 id=\"%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB\">#</a> はじめに</h1><h2 id=\"solid-%E3%82%92%E8%A9%A6%E3%81%99\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#solid-%E3%82%92%E8%A9%A6%E3%81%99\">#</a> Solid を試す</h2><p>Solid を使い始める最も簡単な方法は、オンラインで試すことです。<a href=\"https://playground.solidjs.com\">https://playground.solidjs.com</a> の REPL は、アイデアを試すのに最適な方法です。また、いくつかのサンプルを編集できる <a href=\"https://codesandbox.io/\">https://codesandbox.io/</a> もあります。</p><p>また、ターミナルで以下のコマンドを実行して、シンプルな <a href=\"https://vitejs.dev/\">Vite</a> テンプレートを使用することもできます:</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#d73a49\">&gt;</span><span style=\"color:#24292e\"> npx degit solidjs/templates/js my-app</span></span>\n<span class=\"line\"><span style=\"color:#d73a49\">&gt;</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">cd</span><span style=\"color:#24292e\"> my-app</span></span>\n<span class=\"line\"><span style=\"color:#d73a49\">&gt;</span><span style=\"color:#24292e\"> npm i </span><span style=\"color:#6a737d\"># or yarn or pnpm</span></span>\n<span class=\"line\"><span style=\"color:#d73a49\">&gt;</span><span style=\"color:#24292e\"> npm run dev </span><span style=\"color:#6a737d\"># or yarn or pnpm</span></span>\n<span class=\"line\"></span></code></pre><p>または TypeScript 向けに:</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#d73a49\">&gt;</span><span style=\"color:#24292e\"> npx degit solidjs/templates/ts my-app</span></span>\n<span class=\"line\"><span style=\"color:#d73a49\">&gt;</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">cd</span><span style=\"color:#24292e\"> my-app</span></span>\n<span class=\"line\"><span style=\"color:#d73a49\">&gt;</span><span style=\"color:#24292e\"> npm i </span><span style=\"color:#6a737d\"># or yarn or pnpm</span></span>\n<span class=\"line\"><span style=\"color:#d73a49\">&gt;</span><span style=\"color:#24292e\"> npm run dev </span><span style=\"color:#6a737d\"># or yarn or pnpm</span></span>\n<span class=\"line\"></span></code></pre><h2 id=\"solid-%E3%82%92%E5%AD%A6%E3%81%B6\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#solid-%E3%82%92%E5%AD%A6%E3%81%B6\">#</a> Solid を学ぶ</h2><p>Solid はアプリケーションの構成要素として機能する、合成可能な小さなピースがすべてです。これらの部品は主に、多くの浅いトップレベル API を構成する関数です。幸いなことに、これらのほとんどについて知らなくても始めることができます。</p><p>自由に使える構成要素には、主にコンポーネントとリアクティブプリミティブの 2 種類があります。</p><p>コンポーネントは、props オブジェクトを受け取り、ネイティブの DOM 要素や他のコンポーネントを含む JSX 要素を返す関数です。これらはパスカルケースの JSX 要素として表現できます:</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#d73a49\">function</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">MyComponent</span><span style=\"color:#24292e\">(</span><span style=\"color:#e36209\">props</span><span style=\"color:#24292e\">) {</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">return</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;Hello {props.name}&lt;/</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#24292e\">&lt;</span><span style=\"color:#22863a\">MyComponent</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">name</span><span style=\"color:#d73a49\">=</span><span style=\"color:#032f62\">&quot;Solid&quot;</span><span style=\"color:#24292e\"> /&gt;;</span></span>\n<span class=\"line\"></span></code></pre><p>コンポーネントは、それ自体がステートフルではなく、インスタンスを持たないという点で軽量です。代わりに、DOM 要素やリアクティブプリミティブのファクトリ関数として機能します。</p><p>Solid のきめ細かいリアクティビティは、Signal、Memo、Effect の 3 つのシンプルなプリミティブで構築されています。これらが一緒になって、ビューを最新の状態に保つための自動追跡同期エンジンを形成します。リアクティブな計算は、同期的に実行されるシンプルな関数でラップされた式の形をしています。</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> [</span><span style=\"color:#005cc5\">first</span><span style=\"color:#24292e\">, </span><span style=\"color:#005cc5\">setFirst</span><span style=\"color:#24292e\">] </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">createSignal</span><span style=\"color:#24292e\">(</span><span style=\"color:#032f62\">&quot;JSON&quot;</span><span style=\"color:#24292e\">);</span></span>\n<span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> [</span><span style=\"color:#005cc5\">last</span><span style=\"color:#24292e\">, </span><span style=\"color:#005cc5\">setLast</span><span style=\"color:#24292e\">] </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">createSignal</span><span style=\"color:#24292e\">(</span><span style=\"color:#032f62\">&quot;Bourne&quot;</span><span style=\"color:#24292e\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6f42c1\">createEffect</span><span style=\"color:#24292e\">(() </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> console.</span><span style=\"color:#6f42c1\">log</span><span style=\"color:#24292e\">(</span><span style=\"color:#032f62\">`${</span><span style=\"color:#6f42c1\">first</span><span style=\"color:#032f62\">()</span><span style=\"color:#032f62\">} ${</span><span style=\"color:#6f42c1\">last</span><span style=\"color:#032f62\">()</span><span style=\"color:#032f62\">}`</span><span style=\"color:#24292e\">));</span></span>\n<span class=\"line\"></span></code></pre><p><a href=\"#%E3%83%AA%E3%82%A2%E3%82%AF%E3%83%86%E3%82%A3%E3%83%93%E3%83%86%E3%82%A3\">Solid のリアクティビティ</a>と <a href=\"#%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0\">Solid のレンダリング</a>の詳細をご覧いただけます。</p><h2 id=\"solid-%E3%81%AB%E8%80%83%E3%81%88%E3%82%8B\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#solid-%E3%81%AB%E8%80%83%E3%81%88%E3%82%8B\">#</a> Solid に考える</h2><p>Solid の設計には、Web サイトやアプリケーションを構築する上で、どのような原則や価値観が最適なのかといういくつもの意見が込められています。Solid の背後にある哲学を知っていれば、Solid を習得し、使うことが容易になるでしょう。</p><h3 id=\"1.-%E5%AE%A3%E8%A8%80%E5%9E%8B%E3%83%87%E3%83%BC%E3%82%BF\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#1.-%E5%AE%A3%E8%A8%80%E5%9E%8B%E3%83%87%E3%83%BC%E3%82%BF\">#</a> 1. 宣言型データ</h3><p>宣言型データとは、データの動作の記述を宣言に結びつけることです。データの動作のすべての側面を 1 つの場所にパッケージ化することで、簡単に構成できます。</p><h3 id=\"2.-%E6%B6%88%E3%81%88%E3%82%8B%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#2.-%E6%B6%88%E3%81%88%E3%82%8B%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88\">#</a> 2. 消えるコンポーネント</h3><p>更新を考慮せずにコンポーネントを構造化することは難しいです。Solid の更新はコンポーネントから完全に独立しています。コンポーネント関数は一度呼び出されると消滅してしまいます。コンポーネントはコードを整理するために存在し、他の用途はあまりありません。</p><h3 id=\"3.-%E3%83%AA%E3%83%BC%E3%83%89%2F%E3%83%A9%E3%82%A4%E3%83%88%E3%81%AE%E5%88%86%E9%9B%A2\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#3.-%E3%83%AA%E3%83%BC%E3%83%89%2F%E3%83%A9%E3%82%A4%E3%83%88%E3%81%AE%E5%88%86%E9%9B%A2\">#</a> 3. リード/ライトの分離</h3><p>正確な制御と予測可能性がより良いシステムを作ります。一方通行のフローを強制するための真の不変性は必要ありませんが、どの使用者が書き込んでいいか/いけないかを意識的に決定する能力があればよいのです。</p><h3 id=\"4.-%E3%82%B7%E3%83%B3%E3%83%97%E3%83%AB%E3%81%AF%E3%82%A4%E3%83%BC%E3%82%B8%E3%83%BC%E3%81%AB%E5%8B%9D%E3%82%8B\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#4.-%E3%82%B7%E3%83%B3%E3%83%97%E3%83%AB%E3%81%AF%E3%82%A4%E3%83%BC%E3%82%B8%E3%83%BC%E3%81%AB%E5%8B%9D%E3%82%8B\">#</a> 4. シンプルはイージーに勝る</h3><p>きめ細やかなリアクティビティのために苦労して得た教訓です。明示的で一貫性のある規約は、より多くの努力が必要な場合でも、それだけの価値があります。目的は、基盤となる最小限のツールを提供することです。</p><h2 id=\"web-%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#web-%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88\">#</a> Web コンポーネント</h2><p>Solid は、Web コンポーネントを第一級市民として持ちたいという願望を持って生まれました。時とともに、その設計は進化し、目標も変わりました。しかし、Solid は依然として Web コンポーネントを作成するための優れた方法です。<a href=\"https://github.com/solidjs/solid/tree/main/packages/solid-element\">Solid Element</a> を使うと Solid の関数コンポーネントを記述、ラップして、小さくてパフォーマンスの高い Web コンポーネントを作成できます。Solid アプリの内部では、Solid Element は Solid の Context API を活用でき、Solid の Portal は Shadow DOM の隔離されたスタイルをサポートします。</p><h2 id=\"%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0\">#</a> サーバーレンダリング</h2><p>Solid は、真のアイソモーフィックな開発を可能にする動的なサーバーサイドレンダリングソリューションを備えています。Solid の Resource プリミティブを使用することで非同期データのリクエストが簡単にでき、さらに重要なことに、クライアントとブラウザの間で自動的にシリアライズおよび同期されます。</p><p>Solid はサーバー上での非同期レンダリングとストリームレンダリングをサポートしているため、コードを一方的に記述し、それをサーバー上で実行できます。つまり、<a href=\"https://reactjs.org/docs/concurrent-mode-suspense.html#approach-3-render-as-you-fetch-using-suspense\">render-as-you-fetch</a> やコード分割などの機能が Solid でも機能するということです。</p><p>詳細については、<a href=\"#%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%82%B5%E3%82%A4%E3%83%89%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0\">サーバーガイド</a>をご覧ください。</p><h2 id=\"%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E3%81%AA%E3%81%97%EF%BC%9F\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E3%81%AA%E3%81%97%EF%BC%9F\">#</a> コンパイルなし？</h2><p>JSX が嫌い？ 式をラップするのを手動で作業したり、パフォーマンスが低下したり、バンドルサイズが大きくなっても構わないですか？ 代わりにタグ付きテンプレートリテラルや HyperScript を使って、コンパイルされない環境で Solid アプリを作成することもできます。</p><p><a href=\"https://www.skypack.dev/\">Skypack</a> を使って、ブラウザから直接実行することもできます:</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#24292e\">&lt;</span><span style=\"color:#22863a\">html</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  &lt;</span><span style=\"color:#22863a\">body</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    &lt;</span><span style=\"color:#22863a\">script</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">type</span><span style=\"color:#24292e\">=</span><span style=\"color:#032f62\">&quot;module&quot;</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">      </span><span style=\"color:#d73a49\">import</span><span style=\"color:#24292e\"> {</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">        createSignal,</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">        onCleanup,</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">      } </span><span style=\"color:#d73a49\">from</span><span style=\"color:#24292e\"> </span><span style=\"color:#032f62\">&quot;https://cdn.skypack.dev/solid-js&quot;</span><span style=\"color:#24292e\">;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">      </span><span style=\"color:#d73a49\">import</span><span style=\"color:#24292e\"> { render } </span><span style=\"color:#d73a49\">from</span><span style=\"color:#24292e\"> </span><span style=\"color:#032f62\">&quot;https://cdn.skypack.dev/solid-js/web&quot;</span><span style=\"color:#24292e\">;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">      </span><span style=\"color:#d73a49\">import</span><span style=\"color:#24292e\"> html </span><span style=\"color:#d73a49\">from</span><span style=\"color:#24292e\"> </span><span style=\"color:#032f62\">&quot;https://cdn.skypack.dev/solid-js/html&quot;</span><span style=\"color:#24292e\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#24292e\">      </span><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">App</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> () </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> {</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">        </span><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> [</span><span style=\"color:#005cc5\">count</span><span style=\"color:#24292e\">, </span><span style=\"color:#005cc5\">setCount</span><span style=\"color:#24292e\">] </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">createSignal</span><span style=\"color:#24292e\">(</span><span style=\"color:#005cc5\">0</span><span style=\"color:#24292e\">),</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">          </span><span style=\"color:#005cc5\">timer</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">setInterval</span><span style=\"color:#24292e\">(() </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">setCount</span><span style=\"color:#24292e\">(</span><span style=\"color:#6f42c1\">count</span><span style=\"color:#24292e\">() </span><span style=\"color:#d73a49\">+</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">1</span><span style=\"color:#24292e\">), </span><span style=\"color:#005cc5\">1000</span><span style=\"color:#24292e\">);</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">        </span><span style=\"color:#6f42c1\">onCleanup</span><span style=\"color:#24292e\">(() </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">clearInterval</span><span style=\"color:#24292e\">(timer));</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">        </span><span style=\"color:#d73a49\">return</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">html</span><span style=\"color:#032f62\">`&lt;div&gt;${</span><span style=\"color:#24292e\">count</span><span style=\"color:#032f62\">}&lt;/div&gt;`</span><span style=\"color:#24292e\">;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">      };</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">      </span><span style=\"color:#6f42c1\">render</span><span style=\"color:#24292e\">(App, document.body);</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    &lt;/</span><span style=\"color:#22863a\">script</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  &lt;/</span><span style=\"color:#22863a\">body</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">&lt;/</span><span style=\"color:#22863a\">html</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"></span></code></pre><p>これらを TypeScript で動作させるには、対応する DOM Expressions ライブラリが必要であることを覚えておいてください。タグ付きテンプレートリテラルは <a href=\"https://github.com/ryansolid/dom-expressions/tree/main/packages/lit-dom-expressions\">Lit DOM Expressions</a> で使用でき、HyperScript は <a href=\"https://github.com/ryansolid/dom-expressions/tree/main/packages/hyper-dom-expressions\">Hyper DOM Expressions</a> で使用できます。</p></section><section class=\"mt-10\"><h1 id=\"%E3%83%AA%E3%82%A2%E3%82%AF%E3%83%86%E3%82%A3%E3%83%93%E3%83%86%E3%82%A3\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E3%83%AA%E3%82%A2%E3%82%AF%E3%83%86%E3%82%A3%E3%83%93%E3%83%86%E3%82%A3\">#</a> リアクティビティ</h1><p>Solid のデータ管理は、すべての更新を担当する一連の柔軟なリアクティブプリミティブで構築されています。MobX や Vue と非常に似たアプローチをとっていますが、仮想 DOM のために粒度を変えることはありません。Effect や JSX ビューのコードでリアクティブな値にアクセスすると、依存関係が自動的に追跡されます。</p><p>Solid のプリミティブは、主にタプルを返す <code>create</code> を呼び出す形で提供されています。大抵の場合、タプルの最初の要素は読み取り可能なプリミティブで、2 番目の要素はセッターです。読み取り可能な部分のみをプリミティブ名で参照するのが一般的です。</p><p>これは <code>count</code> Signal の変更に基づいて更新される、基本的な自動インクリメントカウンターです。</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#d73a49\">import</span><span style=\"color:#24292e\"> { createSignal, onCleanup } </span><span style=\"color:#d73a49\">from</span><span style=\"color:#24292e\"> </span><span style=\"color:#032f62\">&quot;solid-js&quot;</span><span style=\"color:#24292e\">;</span></span>\n<span class=\"line\"><span style=\"color:#d73a49\">import</span><span style=\"color:#24292e\"> { render } </span><span style=\"color:#d73a49\">from</span><span style=\"color:#24292e\"> </span><span style=\"color:#032f62\">&quot;solid-js/web&quot;</span><span style=\"color:#24292e\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">App</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> () </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> {</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> [</span><span style=\"color:#005cc5\">count</span><span style=\"color:#24292e\">, </span><span style=\"color:#005cc5\">setCount</span><span style=\"color:#24292e\">] </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">createSignal</span><span style=\"color:#24292e\">(</span><span style=\"color:#005cc5\">0</span><span style=\"color:#24292e\">),</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    </span><span style=\"color:#005cc5\">timer</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">setInterval</span><span style=\"color:#24292e\">(() </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">setCount</span><span style=\"color:#24292e\">(</span><span style=\"color:#6f42c1\">count</span><span style=\"color:#24292e\">() </span><span style=\"color:#d73a49\">+</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">1</span><span style=\"color:#24292e\">), </span><span style=\"color:#005cc5\">1000</span><span style=\"color:#24292e\">);</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#6f42c1\">onCleanup</span><span style=\"color:#24292e\">(() </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">clearInterval</span><span style=\"color:#24292e\">(timer));</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">return</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;{</span><span style=\"color:#6f42c1\">count</span><span style=\"color:#24292e\">()}&lt;/</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6f42c1\">render</span><span style=\"color:#24292e\">(() </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#22863a\">App</span><span style=\"color:#24292e\"> /&gt;, document.</span><span style=\"color:#6f42c1\">getElementById</span><span style=\"color:#24292e\">(</span><span style=\"color:#032f62\">&quot;app&quot;</span><span style=\"color:#24292e\">));</span></span>\n<span class=\"line\"></span></code></pre><h2 id=\"%E3%83%97%E3%83%AA%E3%83%9F%E3%83%86%E3%82%A3%E3%83%96%E3%81%AE%E7%B4%B9%E4%BB%8B\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E3%83%97%E3%83%AA%E3%83%9F%E3%83%86%E3%82%A3%E3%83%96%E3%81%AE%E7%B4%B9%E4%BB%8B\">#</a> プリミティブの紹介</h2><p>Solid は、Signal、Memo、Effect の 3 つの主要なプリミティブで構成されています。これらのプリミティブの核となるのは、Memo と Effect をラップすることで Signal（と Memo）を追跡するオブザーバーパターンです。</p><p>Signal は最もシンプルなプリミティブです。Signal には値が含まれており、読み書きされたときにインターセプトできるように get と set の関数が用意されています。</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> [</span><span style=\"color:#005cc5\">count</span><span style=\"color:#24292e\">, </span><span style=\"color:#005cc5\">setCount</span><span style=\"color:#24292e\">] </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">createSignal</span><span style=\"color:#24292e\">(</span><span style=\"color:#005cc5\">0</span><span style=\"color:#24292e\">);</span></span>\n<span class=\"line\"></span></code></pre><p>Effect は、Signal の読み込みをラップし、依存する Signal の値が変更されるたびに再実行する関数です。これは、レンダリングなどの副作用を作成するのに便利です。</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#6f42c1\">createEffect</span><span style=\"color:#24292e\">(() </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> console.</span><span style=\"color:#6f42c1\">log</span><span style=\"color:#24292e\">(</span><span style=\"color:#032f62\">&quot;The latest count is&quot;</span><span style=\"color:#24292e\">, </span><span style=\"color:#6f42c1\">count</span><span style=\"color:#24292e\">()));</span></span>\n<span class=\"line\"></span></code></pre><p>最後に、Memo はキャッシュされた派生値です。Memo は Signal と Effect の両方の特性を持っています。依存する Signal を追跡し、それらが変更されたときにのみ再実行され、Memo 自体も追跡可能な Signal です。</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">fullName</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">createMemo</span><span style=\"color:#24292e\">(() </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> </span><span style=\"color:#032f62\">`${</span><span style=\"color:#6f42c1\">firstName</span><span style=\"color:#032f62\">()</span><span style=\"color:#032f62\">} ${</span><span style=\"color:#6f42c1\">lastName</span><span style=\"color:#032f62\">()</span><span style=\"color:#032f62\">}`</span><span style=\"color:#24292e\">);</span></span>\n<span class=\"line\"></span></code></pre><h2 id=\"%E5%8B%95%E4%BD%9C%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E5%8B%95%E4%BD%9C%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF\">#</a> 動作の仕組み</h2><p>Signal は、サブスクリプションのリストを保持するイベントエミッタです。Signal は、値が変わるたびにサブスクライバーに通知します。</p><p>さらに興味深いのは、これらのサブスクリプションがどのように行われるかということです。Solid は自動的な依存関係追跡を使用しています。データが変更されると自動的に更新されます。</p><p>この秘訣は、ランタイムのグローバルスタックにあります。Effect や Memo が開発者から提供された関数を実行（または再実行）する前に、そのスタックに自分自身をプッシュします。そして、読み込まれた Signal は、スタック上に現在のリスナーがあるかどうかをチェックし、あればそのリスナーをサブスクリプションに追加します。</p><p>このように考えることができます:</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#d73a49\">function</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">createSignal</span><span style=\"color:#24292e\">(</span><span style=\"color:#e36209\">value</span><span style=\"color:#24292e\">) {</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">subscribers</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">new</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">Set</span><span style=\"color:#24292e\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">read</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> () </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> {</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    </span><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">listener</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">getCurrentListener</span><span style=\"color:#24292e\">();</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    </span><span style=\"color:#d73a49\">if</span><span style=\"color:#24292e\"> (listener) subscribers.</span><span style=\"color:#6f42c1\">add</span><span style=\"color:#24292e\">(listener);</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    </span><span style=\"color:#d73a49\">return</span><span style=\"color:#24292e\"> value;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  };</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">write</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> (</span><span style=\"color:#e36209\">nextValue</span><span style=\"color:#24292e\">) </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> {</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    value </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> nextValue;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    </span><span style=\"color:#d73a49\">for</span><span style=\"color:#24292e\"> (</span><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">sub</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">of</span><span style=\"color:#24292e\"> subscribers) sub.</span><span style=\"color:#6f42c1\">run</span><span style=\"color:#24292e\">();</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  };</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">return</span><span style=\"color:#24292e\"> [read, write];</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">}</span></span>\n<span class=\"line\"></span></code></pre><p>これで、Signal を更新するたびに、どの Effect を再実行すればよいかがわかります。シンプルで効果的です。実際の実装はもっと複雑ですが、これが、起こっていることの根幹です。</p><p>リアクティビティの仕組みをより詳しく理解するには、以下の記事が役立ちます:</p><p><a href=\"https://dev.to/ryansolid/a-hands-on-introduction-to-fine-grained-reactivity-3ndf\">A Hands-on Introduction to Fine-Grained Reactivity</a></p><p><a href=\"https://dev.to/ryansolid/building-a-reactive-library-from-scratch-1i0p\">Building a Reactive Library from Scratch</a></p><p><a href=\"https://indepth.dev/posts/1289/solidjs-reactivity-to-rendering\">SolidJS: Reactivity to Rendering</a></p><h2 id=\"%E8%80%83%E6%85%AE%E3%81%99%E3%81%B9%E3%81%8D%E7%82%B9\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E8%80%83%E6%85%AE%E3%81%99%E3%81%B9%E3%81%8D%E7%82%B9\">#</a> 考慮すべき点</h2><p>リアクティビティに対するこのアプローチは、非常にパワフルでダイナミックです。条件付きコードの異なるブランチを実行することで、依存関係がその場で変化することに対応できます。また、何段階もの間接参照でも機能します。追跡スコープ内で実行された関数もすべて追跡されます。</p><p>ただし、注意しなければならない重要な動作とトレードオフがいくつかあります。</p><ol> <li> <p>すべてのリアクティビティは、直接またはゲッター/プロキシの下に隠されているかどうかにかかわらず関数の呼び出しから追跡され、プロパティアクセスによってトリガーされます。つまり、どこでリアクティブオブジェクトのプロパティにアクセスするかが重要になります。</p> </li> <li> <p>制御フローからのコンポーネントやコールバックは、スコープを追跡せず、一度しか実行されません。つまり、コンポーネント内のトップレベルでロジックを実行したり分割代入しても、再実行されないということです。コードのその部分を再評価するためには、他のリアクティブプリミティブや JSX からこれらの Signal、Store、props にアクセスする必要があります。</p> </li> <li> <p>この方法では、同期的にしか追跡できません。Effect で setTimeout があったり、async 関数を使用したりしても、事後に非同期を実行するコードは追跡されません。</p> </li> </ol></section><section class=\"mt-10\"><h1 id=\"%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0\">#</a> レンダリング</h1><p>Solid は、JSX、タグ付きテンプレートリテラル、および Solid の HyperScript バリアントの 3 つの形式でテンプレートをサポートしていますが、JSX が主流となっています。その理由は？ JSX は、コンパイルのために作られた優れた DSL です。明確な構文を持ち、TypeScript をサポートし、Babel と連携し、Code Syntax Highlighting や Prettier などのツールをサポートしています。基本的にすべてを無料で提供してくれるツールを使うのは現実的なことでした。コンパイルされたソリューションとして、素晴らしい DX を提供します。こんなに広くサポートされているものを使えるのに、なぜカスタム構文 DSL で苦労しているのですか？</p><h2 id=\"jsx-%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#jsx-%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB\">#</a> JSX コンパイル</h2><p>レンダリングは、JSX テンプレートを最適化されたネイティブな js コードに事前コンパイルすることが伴います。JSX コードは以下のように構成されます:</p><ul> <li>インスタンス化されるたびに複製されるテンプレート DOM 要素</li> <li>firstChild と nextSibling のみを使用する一連の参照宣言</li> <li>作成された要素を更新するためのきめ細かな計算</li> </ul><p>このアプローチは、document.createElement を使って要素をひとつずつ作成するよりもパフォーマンスが高く、コード量も少なくて済みます。</p><h2 id=\"%E5%B1%9E%E6%80%A7%E3%81%A8%E3%83%97%E3%83%AD%E3%83%91%E3%83%86%E3%82%A3\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E5%B1%9E%E6%80%A7%E3%81%A8%E3%83%97%E3%83%AD%E3%83%91%E3%83%86%E3%82%A3\">#</a> 属性とプロパティ</h2><p>Solid は、属性の大文字小文字を区別しないなど、HTML の慣習を可能な限り反映しようとしています。</p><p>ネイティブ要素の JSX のすべての属性の大部分は、DOM 属性として設定されます。静的な値は、複製されるテンプレートに直接組み込まれます。追加の機能を提供する <code>class</code>、<code>style</code>、<code>value</code>、<code>innerHTML</code> のようないくつかの例外もあります。</p><p>しかし、カスタム要素（ネイティブの組み込みを除く）は動的な場合、プロパティがデフォルトとなります。これは、より複雑なデータ型を扱うためです。これは、標準的なのスネークケースの属性名 <code>some-attr</code> をキャメルケース <code>someAttr</code> に変換することで実現しています。</p><p>しかし、名前空間ディレクティブを使って、この動作を直接制御することは可能です。属性を <code>attr:</code> で強制的に指定したり、プロパティを <code>prop:</code> で強制的に指定できます:</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#24292e\">&lt;</span><span style=\"color:#22863a\">my-element</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">prop</span><span style=\"color:#24292e\">:</span><span style=\"color:#005cc5\">UniqACC</span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\">{state.value} </span><span style=\"color:#005cc5\">attr</span><span style=\"color:#24292e\">:</span><span style=\"color:#005cc5\">title</span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\">{state.title} /&gt;</span></span>\n<span class=\"line\"></span></code></pre><blockquote> <p><strong>注意:</strong> 静的属性は、複製される html テンプレートの一部として作成されます。固定および動的な式は、JSX のバインディング順に後から適用されます。ほとんどの DOM 要素では問題ありませんが、<code>type='range'</code>を持つ input 要素のように、順序が重要になるものもあります。要素をバインドする際には、この点に注意してください。</p> </blockquote><h2 id=\"%E3%82%A8%E3%83%B3%E3%83%88%E3%83%AA%E3%83%BC\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E3%82%A8%E3%83%B3%E3%83%88%E3%83%AA%E3%83%BC\">#</a> エントリー</h2><p>Solid をマウントする最も簡単な方法は、'solid-js/web' から render をインポートすることです。<code>render</code> は第一引数に関数、第二引数にマウントコンテナを取り、廃棄メソッドを返します。この <code>render</code> は自動的にリアクティブルートを作成し、マウントコンテナへのレンダリングを処理します。最高のパフォーマンスを得るためには、子のない要素を使用してください。</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#d73a49\">import</span><span style=\"color:#24292e\"> { render } </span><span style=\"color:#d73a49\">from</span><span style=\"color:#24292e\"> </span><span style=\"color:#032f62\">&quot;solid-js/web&quot;</span><span style=\"color:#24292e\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6f42c1\">render</span><span style=\"color:#24292e\">(() </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#22863a\">App</span><span style=\"color:#24292e\"> /&gt;, document.</span><span style=\"color:#6f42c1\">getElementById</span><span style=\"color:#24292e\">(</span><span style=\"color:#032f62\">&quot;main&quot;</span><span style=\"color:#24292e\">));</span></span>\n<span class=\"line\"></span></code></pre><blockquote> <p><strong>重要</strong> 第一引数は関数である必要があります。そうしないと、リアクティブシステムを適切に追跡し、スケジュールできません。この単純な不備により、Effects は実行されなくなります。</p> </blockquote><h2 id=\"%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88\">#</a> コンポーネント</h2><p>Solid のコンポーネントは、単なるパスカル（キャピタル）ケースの関数です。最初の引数は props オブジェクトであり、実際の DOM ノードを返します。</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">Parent</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> () </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> (</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  &lt;</span><span style=\"color:#22863a\">section</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    &lt;</span><span style=\"color:#22863a\">Label</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">greeting</span><span style=\"color:#d73a49\">=</span><span style=\"color:#032f62\">&quot;Hello&quot;</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">      &lt;</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;John&lt;/</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    &lt;/</span><span style=\"color:#22863a\">Label</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  &lt;/</span><span style=\"color:#22863a\">section</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">Label</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> (</span><span style=\"color:#e36209\">props</span><span style=\"color:#24292e\">) </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> (</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  &lt;&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    &lt;</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;{props.greeting}&lt;/</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    {props.children}</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  &lt;/&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">);</span></span>\n<span class=\"line\"></span></code></pre><p>すべての JSX ノードは実際の DOM ノードなので、トップレベルコンポーネントの唯一の責任は、それらを DOM に追加することです。</p><h2 id=\"props\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#props\">#</a> Props</h2><p>React や Vue、Angular やその他のフレームワークと同様に、Solid ではコンポーネントにプロパティを定義して、子コンポーネントにデータを渡すことができます。ここでは、親コンポーネントが文字列 &quot;Hello&quot; を <code>greeting</code> プロパティを介して <code>Label</code> コンポーネントに渡しています。</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">Parent</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> () </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> (</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  &lt;</span><span style=\"color:#22863a\">section</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    &lt;</span><span style=\"color:#22863a\">Label</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">greeting</span><span style=\"color:#d73a49\">=</span><span style=\"color:#032f62\">&quot;Hello&quot;</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">      &lt;</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;John&lt;/</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    &lt;/</span><span style=\"color:#22863a\">Label</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  &lt;/</span><span style=\"color:#22863a\">section</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">);</span></span>\n<span class=\"line\"></span></code></pre><p>上の例では、<code>greeting</code> に設定されている値は静的なものですが、動的な値を設定することもできます。例えば:</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">Parent</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> () </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> {</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> [</span><span style=\"color:#005cc5\">greeting</span><span style=\"color:#24292e\">, </span><span style=\"color:#005cc5\">setGreeting</span><span style=\"color:#24292e\">] </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">createSignal</span><span style=\"color:#24292e\">(</span><span style=\"color:#032f62\">&quot;Hello&quot;</span><span style=\"color:#24292e\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">return</span><span style=\"color:#24292e\"> (</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    &lt;</span><span style=\"color:#22863a\">section</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">      &lt;</span><span style=\"color:#22863a\">Label</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">greeting</span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\">{</span><span style=\"color:#6f42c1\">greeting</span><span style=\"color:#24292e\">()}&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">        &lt;</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;John&lt;/</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">      &lt;/</span><span style=\"color:#22863a\">Label</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    &lt;/</span><span style=\"color:#22863a\">section</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  );</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">};</span></span>\n<span class=\"line\"></span></code></pre><p>コンポーネントは、<code>props</code> という引数を介して渡されたプロパティにアクセスできます。</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">Label</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> (</span><span style=\"color:#e36209\">props</span><span style=\"color:#24292e\">) </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> (</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  &lt;&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    &lt;</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;{props.greeting}&lt;/</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    {props.children}</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  &lt;/&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">);</span></span>\n<span class=\"line\"></span></code></pre><p>他のフレームワークとは異なり、コンポーネントの <code>props</code> に対してオブジェクトの分割代入を使用することはできません。舞台裏では、<code>props</code> オブジェクトが Object のゲッターに依存して、値を遅延取得するためです。分割代入を使用すると、<code>props</code> のリアクティビティが損なわれます。</p><p>この例は、Solid で props にアクセスする「正しい」方法を示しています:</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#6a737d\">// ここでは、`props.name` が期待通りに更新されます</span></span>\n<span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">MyComponent</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> (</span><span style=\"color:#e36209\">props</span><span style=\"color:#24292e\">) </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;{props.name}&lt;/</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;;</span></span>\n<span class=\"line\"></span></code></pre><p>この例は、Solid での間違った props へのアクセス方法を示しています:</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#6a737d\">// これはだめ</span></span>\n<span class=\"line\"><span style=\"color:#6a737d\">// ここでは、`props.name` は `name` に分解されるため、更新されません（つまり、リアクティブではない）</span></span>\n<span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">MyComponent</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> ({ </span><span style=\"color:#e36209\">name</span><span style=\"color:#24292e\"> }) </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;{name}&lt;/</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;;</span></span>\n<span class=\"line\"></span></code></pre><p>props オブジェクトは、使っているときは普通のオブジェクトのように見えますが（Typescript ユーザーは props オブジェクトが普通のオブジェクトのように型付けされていることに気づくでしょう）、実際には Signal に似たリアクティブなオブジェクトです。これにはいくつかの意味があります。</p><p>多くの JSX フレームワークとは異なり、Solid の関数コンポーネントは（レンダリングサイクルごとではなく）一度しか実行されないため、以下の例は期待通りには動作しません。</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#d73a49\">import</span><span style=\"color:#24292e\"> { createSignal } </span><span style=\"color:#d73a49\">from</span><span style=\"color:#24292e\"> </span><span style=\"color:#032f62\">&quot;solid-js&quot;</span><span style=\"color:#24292e\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">BasicComponent</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> (</span><span style=\"color:#e36209\">props</span><span style=\"color:#24292e\">) </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> {</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">value</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> props.value </span><span style=\"color:#d73a49\">||</span><span style=\"color:#24292e\"> </span><span style=\"color:#032f62\">&quot;default&quot;</span><span style=\"color:#24292e\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">return</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;{value}&lt;/</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#d73a49\">export</span><span style=\"color:#e36209\"> </span><span style=\"color:#d73a49\">default</span><span style=\"color:#e36209\"> </span><span style=\"color:#d73a49\">function</span><span style=\"color:#e36209\"> </span><span style=\"color:#6f42c1\">Form</span><span style=\"color:#e36209\">() </span><span style=\"color:#24292e\">{</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> [</span><span style=\"color:#005cc5\">value</span><span style=\"color:#24292e\">, </span><span style=\"color:#005cc5\">setValue</span><span style=\"color:#24292e\">] </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">createSignal</span><span style=\"color:#24292e\">(</span><span style=\"color:#032f62\">&quot;&quot;</span><span style=\"color:#24292e\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">return</span><span style=\"color:#24292e\"> (</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    &lt;</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">      &lt;</span><span style=\"color:#22863a\">BasicComponent</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">value</span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\">{</span><span style=\"color:#6f42c1\">value</span><span style=\"color:#24292e\">()} /&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">      &lt;</span><span style=\"color:#22863a\">input</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">type</span><span style=\"color:#d73a49\">=</span><span style=\"color:#032f62\">&quot;text&quot;</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">oninput</span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\">{(</span><span style=\"color:#e36209\">e</span><span style=\"color:#24292e\">) </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">setValue</span><span style=\"color:#24292e\">(e.currentTarget.value)} /&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    &lt;/</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  );</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">}</span></span>\n<span class=\"line\"></span></code></pre><p>この例では、おそらく <code>BasicComponent</code> が <code>input</code> に入力された現在の値を表示することを望んでいます。しかし、覚えておいてほしいのですが、<code>BasicComponent</code> 関数は、コンポーネントが最初に作成されたときに一度だけ実行されます。このとき（作成時）、<code>props.value</code> は <code>''</code> と等しくなります。これは、<code>BasicComponent</code> の <code>const value</code> が <code>'default'</code> に解決され、更新されないことを意味します。<code>props</code> オブジェクトはリアクティブですが、<code>const value = props.value || 'default';</code> で props にアクセスすることは、Solid の観察可能な範囲外であるため、props が変更されても自動的に再評価されません。</p><p>では、この問題を解決するにはどうすればよいのでしょうか？</p><p>一般的には、Solid が観測できる場所で <code>props</code> にアクセスする必要があります。一般的には、JSX 内部や、<code>createMemo</code>、<code>createEffect</code>、または thunk（<code>() =&gt; ...</code> 訳注: 引数を取らず値を返す関数のこと）の内部を意味します。ここでは、期待通りに動作する 1 つのソリューションを紹介します:</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">BasicComponent</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> (</span><span style=\"color:#e36209\">props</span><span style=\"color:#24292e\">) </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> {</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">return</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;{props.value </span><span style=\"color:#d73a49\">||</span><span style=\"color:#24292e\"> </span><span style=\"color:#032f62\">&quot;default&quot;</span><span style=\"color:#24292e\">}&lt;/</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">};</span></span>\n<span class=\"line\"></span></code></pre><p>これは、同等に、関数に巻き上げることができます:</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">BasicComponent</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> (</span><span style=\"color:#e36209\">props</span><span style=\"color:#24292e\">) </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> {</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">value</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> () </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> props.value </span><span style=\"color:#d73a49\">||</span><span style=\"color:#24292e\"> </span><span style=\"color:#032f62\">&quot;default&quot;</span><span style=\"color:#24292e\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">return</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;{</span><span style=\"color:#6f42c1\">value</span><span style=\"color:#24292e\">()}&lt;/</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">};</span></span>\n<span class=\"line\"></span></code></pre><p>もうひとつの選択肢として、コストのかかる計算の場合は <code>createMemo</code> を使う方法もあります。例えば:</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">BasicComponent</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> (</span><span style=\"color:#e36209\">props</span><span style=\"color:#24292e\">) </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> {</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">value</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">createMemo</span><span style=\"color:#24292e\">(() </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> props.value </span><span style=\"color:#d73a49\">||</span><span style=\"color:#24292e\"> </span><span style=\"color:#032f62\">&quot;default&quot;</span><span style=\"color:#24292e\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">return</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;{</span><span style=\"color:#6f42c1\">value</span><span style=\"color:#24292e\">()}&lt;/</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">};</span></span>\n<span class=\"line\"></span></code></pre><p>あるいはヘルパーを使用する</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">BasicComponent</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> (</span><span style=\"color:#e36209\">props</span><span style=\"color:#24292e\">) </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> {</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  props </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">mergeProps</span><span style=\"color:#24292e\">({ value: </span><span style=\"color:#032f62\">&quot;default&quot;</span><span style=\"color:#24292e\"> }, props);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">return</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;{props.value}&lt;/</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">};</span></span>\n<span class=\"line\"></span></code></pre><p>注意として、以下の例は動作<strong>しません</strong>:</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#6a737d\">// だめ</span></span>\n<span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">BasicComponent</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> (</span><span style=\"color:#e36209\">props</span><span style=\"color:#24292e\">) </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> {</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> { </span><span style=\"color:#e36209\">value</span><span style=\"color:#24292e\">: </span><span style=\"color:#005cc5\">valueProp</span><span style=\"color:#24292e\"> } </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> props;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">value</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">createMemo</span><span style=\"color:#24292e\">(() </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> valueProp </span><span style=\"color:#d73a49\">||</span><span style=\"color:#24292e\"> </span><span style=\"color:#032f62\">&quot;default&quot;</span><span style=\"color:#24292e\">);</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">return</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;{</span><span style=\"color:#6f42c1\">value</span><span style=\"color:#24292e\">()}&lt;/</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6a737d\">// だめ</span></span>\n<span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">BasicComponent</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> (</span><span style=\"color:#e36209\">props</span><span style=\"color:#24292e\">) </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> {</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">valueProp</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> prop.value;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">value</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">createMemo</span><span style=\"color:#24292e\">(() </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> valueProp </span><span style=\"color:#d73a49\">||</span><span style=\"color:#24292e\"> </span><span style=\"color:#032f62\">&quot;default&quot;</span><span style=\"color:#24292e\">);</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">return</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;{</span><span style=\"color:#6f42c1\">value</span><span style=\"color:#24292e\">()}&lt;/</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">};</span></span>\n<span class=\"line\"></span></code></pre><p>Solid のコンポーネントは、そのパフォーマンスの重要な部分です。Solid の「消える」コンポーネントのアプローチは、遅延 props 評価によって実現されています。props の式をすぐに評価して値を渡すのではなく、子で props にアクセスするまで実行を延期します。そうすることで、最後の瞬間まで実行を延期し、通常は DOM バインディングの中で実行し、パフォーマンスを最大化します。これにより、階層がフラットになり、コンポーネントのツリーを維持する必要がなくなります。</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#24292e\">&lt;</span><span style=\"color:#22863a\">Component</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">prop1</span><span style=\"color:#d73a49\">=</span><span style=\"color:#032f62\">&quot;static&quot;</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">prop2</span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\">{state.dynamic} /&gt;;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6a737d\">// だいたいこのようにコンパイルされます:</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6a737d\">// コンポーネント本体を分離し、コストのかかる更新を防ぐために、追跡を解除します</span></span>\n<span class=\"line\"><span style=\"color:#6f42c1\">untrack</span><span style=\"color:#24292e\">(() </span><span style=\"color:#d73a49\">=&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#6f42c1\">Component</span><span style=\"color:#24292e\">({</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    prop1: </span><span style=\"color:#032f62\">&quot;static&quot;</span><span style=\"color:#24292e\">,</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    </span><span style=\"color:#6a737d\">// 動的な式なので、ゲッターでラップ</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    </span><span style=\"color:#d73a49\">get</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">prop2</span><span style=\"color:#24292e\">() {</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">      </span><span style=\"color:#d73a49\">return</span><span style=\"color:#24292e\"> state.dynamic;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    },</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  })</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">);</span></span>\n<span class=\"line\"></span></code></pre><p>リアクティビティを維持するために、Solid にはいくつかの props ヘルパーがあります:</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#6a737d\">// デフォルト props</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">props </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">mergeProps</span><span style=\"color:#24292e\">({ name: </span><span style=\"color:#032f62\">&quot;Smith&quot;</span><span style=\"color:#24292e\"> }, props);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6a737d\">// props の複製</span></span>\n<span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">newProps</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">mergeProps</span><span style=\"color:#24292e\">(props);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6a737d\">// props のマージ</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">props </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">mergeProps</span><span style=\"color:#24292e\">(props, otherProps);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6a737d\">// props を複数の props オブジェクトに分割</span></span>\n<span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> [</span><span style=\"color:#005cc5\">local</span><span style=\"color:#24292e\">, </span><span style=\"color:#005cc5\">others</span><span style=\"color:#24292e\">] </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">splitProps</span><span style=\"color:#24292e\">(props, [</span><span style=\"color:#032f62\">&quot;className&quot;</span><span style=\"color:#24292e\">])</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">&lt;</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\"> {</span><span style=\"color:#d73a49\">...</span><span style=\"color:#24292e\">others} </span><span style=\"color:#005cc5\">className</span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\">{</span><span style=\"color:#6f42c1\">cx</span><span style=\"color:#24292e\">(local.className, theme.component)} /&gt;</span></span>\n<span class=\"line\"></span></code></pre><h2 id=\"children\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#children\">#</a> Children</h2><p>Solid は React と同様に JSX Children を扱います。単一の子は <code>props.children</code> の単一の値で、複数の子は値の配列で処理されます。通常は、JSX ビューにそれらを渡します。しかし、それらを操作したい場合は、下流の制御フローを解決して Memo を返す <code>children</code> ヘルパーを使用することをお勧めします。</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#6a737d\">// 単一の子</span></span>\n<span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">Label</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> (</span><span style=\"color:#e36209\">props</span><span style=\"color:#24292e\">) </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">class</span><span style=\"color:#d73a49\">=</span><span style=\"color:#032f62\">&quot;label&quot;</span><span style=\"color:#24292e\">&gt;Hi, { props.children }&lt;/</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#24292e\">&lt;</span><span style=\"color:#22863a\">Label</span><span style=\"color:#24292e\">&gt;&lt;</span><span style=\"color:#22863a\">span</span><span style=\"color:#24292e\">&gt;Josie&lt;/</span><span style=\"color:#22863a\">span</span><span style=\"color:#24292e\">&gt;&lt;/</span><span style=\"color:#22863a\">Label</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6a737d\">// 複数の子</span></span>\n<span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">List</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> (</span><span style=\"color:#e36209\">props</span><span style=\"color:#24292e\">) </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;{props.children}&lt;/</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#24292e\">&lt;</span><span style=\"color:#22863a\">List</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  &lt;</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;First&lt;/</span><span style=\"color:#22863a\">div</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  {state.expression}</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  &lt;</span><span style=\"color:#22863a\">Label</span><span style=\"color:#24292e\">&gt;Judith&lt;/</span><span style=\"color:#22863a\">Label</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">&lt;/</span><span style=\"color:#22863a\">List</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6a737d\">// 子の配列を map 処理</span></span>\n<span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">List</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> (</span><span style=\"color:#e36209\">props</span><span style=\"color:#24292e\">) </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#22863a\">ul</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  &lt;</span><span style=\"color:#22863a\">For</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">each</span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\">{props.children}&gt;{</span><span style=\"color:#e36209\">item</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#22863a\">li</span><span style=\"color:#24292e\">&gt;{item}&lt;/</span><span style=\"color:#22863a\">li</span><span style=\"color:#24292e\">&gt;}&lt;/</span><span style=\"color:#22863a\">For</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">&lt;/</span><span style=\"color:#22863a\">ul</span><span style=\"color:#24292e\">&gt;;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6a737d\">// ヘルパーを使って、子の配列の変更と map 処理</span></span>\n<span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">List</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> (</span><span style=\"color:#e36209\">props</span><span style=\"color:#24292e\">) </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> {</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#6a737d\">// children ヘルパーは値を記憶し、すべての中間的なリアクティビティを解決します</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">memo</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">children</span><span style=\"color:#24292e\">(() </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> props.children);</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#6f42c1\">createEffect</span><span style=\"color:#24292e\">(() </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> {</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    </span><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">children</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">memo</span><span style=\"color:#24292e\">();</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    children.</span><span style=\"color:#6f42c1\">forEach</span><span style=\"color:#24292e\">((</span><span style=\"color:#e36209\">c</span><span style=\"color:#24292e\">) </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> c.classList.</span><span style=\"color:#6f42c1\">add</span><span style=\"color:#24292e\">(</span><span style=\"color:#032f62\">&quot;list-child&quot;</span><span style=\"color:#24292e\">))</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  })</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">return</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#22863a\">ul</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    &lt;</span><span style=\"color:#22863a\">For</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">each</span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\">{</span><span style=\"color:#6f42c1\">memo</span><span style=\"color:#24292e\">()}&gt;{</span><span style=\"color:#e36209\">item</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#22863a\">li</span><span style=\"color:#24292e\">&gt;{item}&lt;/</span><span style=\"color:#22863a\">li</span><span style=\"color:#24292e\">&gt;}&lt;/</span><span style=\"color:#22863a\">For</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  &lt;/</span><span style=\"color:#22863a\">ul</span><span style=\"color:#24292e\">&gt;;</span></span>\n<span class=\"line\"></span></code></pre><p><strong>重要:</strong> Solid は子タグを高価な式として扱い、動的なリアクティブ式と同じようにラップします。つまり、<code>prop</code> へのアクセス時に遅延的に評価されます。ビューで使用する前に分割代入したり、複数回アクセスすることには注意してください。これは、Solid には事前に仮想 DOM ノードを作成してから差分を取るような余裕がないため、これらの <code>prop</code> の解決は遅延的かつ慎重に行わなければならないためです。これを行いたい場合は、<code>children</code> ヘルパーを使用すると、それらがメモ化されます。</p></section><section class=\"mt-10\"><h1 id=\"%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%82%B5%E3%82%A4%E3%83%89%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%82%B5%E3%82%A4%E3%83%89%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0\">#</a> サーバーサイドレンダリング</h1><p>Solid は、JSX テンプレートを超効率的な文字列付加コードにコンパイルすることで、サーバーレンダリングを処理します。これは、babel プラグインまたはプリセットで、<code>generate: &quot;ssr&quot;</code> を渡すことで実現できます。クライアントとサーバーの両方で、ハイドレーションに対応したコードを生成するには、<code>hydratable: true</code> を渡す必要があります。</p><p><code>solid-js</code> と <code>solid-js/web</code> のランタイムは、node 環境で実行する場合には、非リアクティブな対照物と交換されます。他の環境では、<code>node</code> に設定された条件付きエクスポートでサーバーコードをバンドルする必要があります。ほとんどのバンドルツールは、これを行なう方法を持っています。一般的には、エクスポート条件として <code>solid</code> を使用することをお勧めします。また、ライブラリは <code>solid</code> エクスポートでソースを出荷することをお勧めします。</p><p>SSR 用にビルドすると、2 つの別々のバンドルを生成することになるので、若干の設定が必要になります。クライアントのエントリーでは <code>hydrate</code> を使用します:</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#d73a49\">import</span><span style=\"color:#24292e\"> { hydrate } </span><span style=\"color:#d73a49\">from</span><span style=\"color:#24292e\"> </span><span style=\"color:#032f62\">&quot;solid-js/web&quot;</span><span style=\"color:#24292e\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6f42c1\">hydrate</span><span style=\"color:#24292e\">(() </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#22863a\">App</span><span style=\"color:#24292e\"> /&gt;, document);</span></span>\n<span class=\"line\"></span></code></pre><p><em>注意: ドキュメントルートからレンダリングとハイドレーションを行うことが可能です。これにより、JSX ですべてのビューを記述できます。</em></p><p>サーバーのエントリーでは、Solid が提供する 4 つのレンダリングオプションのいずれかを使用できます。それぞれ、出力とドキュメントの先頭に挿入されるスクリプトタグが生成されます。</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#d73a49\">import</span><span style=\"color:#24292e\"> {</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  renderToString,</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  renderToStringAsync,</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  renderToNodeStream,</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  renderToWebStream,</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">} </span><span style=\"color:#d73a49\">from</span><span style=\"color:#24292e\"> </span><span style=\"color:#032f62\">&quot;solid-js/web&quot;</span><span style=\"color:#24292e\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6a737d\">// 同期文字列レンダリング</span></span>\n<span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">html</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">renderToString</span><span style=\"color:#24292e\">(() </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#22863a\">App</span><span style=\"color:#24292e\"> /&gt;);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6a737d\">// 非同期文字列レンダリング</span></span>\n<span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">html</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">await</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">renderToStringAsync</span><span style=\"color:#24292e\">(() </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#22863a\">App</span><span style=\"color:#24292e\"> /&gt;);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6a737d\">// Node Stream API</span></span>\n<span class=\"line\"><span style=\"color:#6f42c1\">pipeToNodeWritable</span><span style=\"color:#24292e\">(App, res);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6a737d\">// Web Stream API （Cloudflare Workers など用）</span></span>\n<span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> { </span><span style=\"color:#005cc5\">readable</span><span style=\"color:#24292e\">, </span><span style=\"color:#005cc5\">writable</span><span style=\"color:#24292e\"> } </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">new</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">TransformStream</span><span style=\"color:#24292e\">();</span></span>\n<span class=\"line\"><span style=\"color:#6f42c1\">pipeToWritable</span><span style=\"color:#24292e\">(() </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#22863a\">App</span><span style=\"color:#24292e\"> /&gt;, writable);</span></span>\n<span class=\"line\"></span></code></pre><p>便利なように <code>solid-js/web</code> は <code>isServer</code> フラグをエクスポートします。これは、ほとんどのバンドラーが、このフラグを持つものをツリーシェイクしたり、このフラグを持つコードでのみ使用されるものをクライアントバンドルからインポートしたりできるので便利です。</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#d73a49\">import</span><span style=\"color:#24292e\"> { isServer } </span><span style=\"color:#d73a49\">from</span><span style=\"color:#24292e\"> </span><span style=\"color:#032f62\">&quot;solid-js/web&quot;</span><span style=\"color:#24292e\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#d73a49\">if</span><span style=\"color:#24292e\"> (isServer) {</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#6a737d\">// サーバーでのみ実行</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">} </span><span style=\"color:#d73a49\">else</span><span style=\"color:#24292e\"> {</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#6a737d\">// ブラウザでのみ実行</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">}</span></span>\n<span class=\"line\"></span></code></pre><h2 id=\"%E3%83%8F%E3%82%A4%E3%83%89%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E3%83%8F%E3%82%A4%E3%83%89%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88\">#</a> ハイドレーションスクリプト</h2><p>Solid のランタイムがロードされる前から徐々にハイドレーションさせるためには、特別なスクリプトをページに挿入する必要があります。このスクリプトは、<code>generateHydrationScript</code> で生成して挿入するか、<code>&lt;HydrationScript /&gt;</code> タグを使用して JSX の一部として含めることができます。</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#d73a49\">import</span><span style=\"color:#24292e\"> { generateHydrationScript } </span><span style=\"color:#d73a49\">from</span><span style=\"color:#24292e\"> </span><span style=\"color:#032f62\">&quot;solid-js/web&quot;</span><span style=\"color:#24292e\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">app</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">renderToString</span><span style=\"color:#24292e\">(() </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> &lt;</span><span style=\"color:#e36209\">App</span><span style=\"color:#24292e\"> /&gt;);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">html</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> </span><span style=\"color:#032f62\">`</span></span>\n<span class=\"line\"><span style=\"color:#032f62\">  &lt;html lang=&quot;en&quot;&gt;</span></span>\n<span class=\"line\"><span style=\"color:#032f62\">    &lt;head&gt;</span></span>\n<span class=\"line\"><span style=\"color:#032f62\">      &lt;title&gt;🔥 Solid SSR 🔥&lt;/title&gt;</span></span>\n<span class=\"line\"><span style=\"color:#032f62\">      &lt;meta charset=&quot;UTF-8&quot; /&gt;</span></span>\n<span class=\"line\"><span style=\"color:#032f62\">      &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span></span>\n<span class=\"line\"><span style=\"color:#032f62\">      &lt;link rel=&quot;stylesheet&quot; href=&quot;/styles.css&quot; /&gt;</span></span>\n<span class=\"line\"><span style=\"color:#032f62\">      ${</span><span style=\"color:#6f42c1\">generateHydrationScript</span><span style=\"color:#032f62\">()</span><span style=\"color:#032f62\">}</span></span>\n<span class=\"line\"><span style=\"color:#032f62\">    &lt;/head&gt;</span></span>\n<span class=\"line\"><span style=\"color:#032f62\">    &lt;body&gt;${</span><span style=\"color:#24292e\">app</span><span style=\"color:#032f62\">}&lt;/body&gt;</span></span>\n<span class=\"line\"><span style=\"color:#032f62\">  &lt;/html&gt;</span></span>\n<span class=\"line\"><span style=\"color:#032f62\">`</span><span style=\"color:#24292e\">;</span></span>\n<span class=\"line\"></span></code></pre><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#d73a49\">import</span><span style=\"color:#24292e\"> { HydrationScript } </span><span style=\"color:#d73a49\">from</span><span style=\"color:#24292e\"> </span><span style=\"color:#032f62\">&quot;solid-js/web&quot;</span><span style=\"color:#24292e\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#d73a49\">const</span><span style=\"color:#24292e\"> </span><span style=\"color:#6f42c1\">App</span><span style=\"color:#24292e\"> </span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\"> () </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> {</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  </span><span style=\"color:#d73a49\">return</span><span style=\"color:#24292e\"> (</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    &lt;</span><span style=\"color:#22863a\">html</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">lang</span><span style=\"color:#d73a49\">=</span><span style=\"color:#032f62\">&quot;en&quot;</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">      &lt;</span><span style=\"color:#22863a\">head</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">        &lt;</span><span style=\"color:#22863a\">title</span><span style=\"color:#24292e\">&gt;🔥 Solid SSR 🔥&lt;/</span><span style=\"color:#22863a\">title</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">        &lt;</span><span style=\"color:#22863a\">meta</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">charset</span><span style=\"color:#d73a49\">=</span><span style=\"color:#032f62\">&quot;UTF-8&quot;</span><span style=\"color:#24292e\"> /&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">        &lt;</span><span style=\"color:#22863a\">meta</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">name</span><span style=\"color:#d73a49\">=</span><span style=\"color:#032f62\">&quot;viewport&quot;</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">content</span><span style=\"color:#d73a49\">=</span><span style=\"color:#032f62\">&quot;width=device-width, initial-scale=1.0&quot;</span><span style=\"color:#24292e\"> /&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">        &lt;</span><span style=\"color:#22863a\">link</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">rel</span><span style=\"color:#d73a49\">=</span><span style=\"color:#032f62\">&quot;stylesheet&quot;</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">href</span><span style=\"color:#d73a49\">=</span><span style=\"color:#032f62\">&quot;/styles.css&quot;</span><span style=\"color:#24292e\"> /&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">        &lt;</span><span style=\"color:#22863a\">HydrationScript</span><span style=\"color:#24292e\"> /&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">      &lt;/</span><span style=\"color:#22863a\">head</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">      &lt;</span><span style=\"color:#22863a\">body</span><span style=\"color:#24292e\">&gt;{</span><span style=\"color:#6a737d\">/*... rest of App*/</span><span style=\"color:#24292e\">}&lt;/</span><span style=\"color:#22863a\">body</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    &lt;/</span><span style=\"color:#22863a\">html</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  );</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">};</span></span>\n<span class=\"line\"></span></code></pre><p>クライアントの実行時に利用できないアセットを挿入するドキュメントからハイドレーションする場合、問題が発生する可能性があります。Solid は <code>&lt;NoHydration&gt;</code> コンポーネントを提供しており、このコンポーネントの子は、サーバー上では通常通り動作しますが、ブラウザ上ではハイドレーションされません。</p><pre class=\"shiki\" style=\"background-color:#fff\"><code><span class=\"line\"><span style=\"color:#24292e\">&lt;</span><span style=\"color:#22863a\">NoHydration</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  {manifest.</span><span style=\"color:#6f42c1\">map</span><span style=\"color:#24292e\">((</span><span style=\"color:#e36209\">m</span><span style=\"color:#24292e\">) </span><span style=\"color:#d73a49\">=&gt;</span><span style=\"color:#24292e\"> (</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">    &lt;</span><span style=\"color:#22863a\">link</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">rel</span><span style=\"color:#d73a49\">=</span><span style=\"color:#032f62\">&quot;modulepreload&quot;</span><span style=\"color:#24292e\"> </span><span style=\"color:#005cc5\">href</span><span style=\"color:#d73a49\">=</span><span style=\"color:#24292e\">{m.href} /&gt;</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">  ))}</span></span>\n<span class=\"line\"><span style=\"color:#24292e\">&lt;/</span><span style=\"color:#22863a\">NoHydration</span><span style=\"color:#24292e\">&gt;</span></span>\n<span class=\"line\"></span></code></pre><h2 id=\"%E9%9D%9E%E5%90%8C%E6%9C%9F%E3%81%8A%E3%82%88%E3%81%B3%E3%82%B9%E3%83%88%E3%83%AA%E3%83%BC%E3%83%9F%E3%83%B3%E3%82%B0-ssr\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E9%9D%9E%E5%90%8C%E6%9C%9F%E3%81%8A%E3%82%88%E3%81%B3%E3%82%B9%E3%83%88%E3%83%AA%E3%83%BC%E3%83%9F%E3%83%B3%E3%82%B0-ssr\">#</a> 非同期およびストリーミング SSR</h2><p>これらのメカニズムは、アプリケーションの動作に関する Solid の知識に基づいて構築されています。先にフェッチしてからレンダリングするのではなく、サーバー上で Suspense と Resource API を使用することで実現しています。Solid は、クライアントと同様に、サーバー上でレンダリングしながらフェッチします。コードや実行パターンも全く同じように書かれています。</p><p>非同期レンダリングは、すべてのサスペンス境界が解決するまで待ってから結果を送信します（静的サイト生成の場合はファイルに書き込みます）。</p><p>ストリーミングは、サーバー上でサスペンスのフォールバックをレンダリングすると同時に、ブラウザに同期コンテンツのフラッシュを開始します。その後、サーバー上で非同期データが終了すると、同じストリームを介してクライアントにデータを送信し、ブラウザがジョブを終了してフォールバックを実際のコンテンツに置き換えることで、サスペンスを解決します。</p><p>この方法の利点:</p><ul> <li>サーバーは非同期データが応答するのを待つ必要がありません。アセットはより早くブラウザにロードされ、ユーザーはより早くコンテンツを見始めることができます。</li> <li>JAMStack のようなクライアントフェッチに比べて、データのロードはサーバー上ですぐに始まり、クライアントの JavaScript がロードされるのを待つ必要はありません。</li> <li>すべてのデータはシリアル化され、サーバーからクライアントに自動的に転送されます。</li> </ul><h2 id=\"ssr-%E3%81%AE%E6%B3%A8%E6%84%8F%E7%82%B9\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#ssr-%E3%81%AE%E6%B3%A8%E6%84%8F%E7%82%B9\">#</a> SSR の注意点</h2><p>Solid のアイソモーフィック SSR ソリューションは、どちらの環境でも同じように動作する単一のコードベースとしてコードを書くことができるという点で非常に強力です。しかし、これによってハイドレーションに期待されることがあります。ほとんどの場合、クライアントでレンダリングされるビューは、サーバーでレンダリングされるビューと同じです。テキストに関しては正確である必要はありませんが、マークアップは構造的に同じであるべきです。</p><p>サーバーでレンダリングされたマーカーを使用して、サーバー上の要素やリソースの位置を一致させます。このため、クライアントとサーバーは同じコンポーネントを使用する必要があります。これは、Solid がクライアントとサーバーで同じようにレンダリングされることを考えると、通常は問題になりません。しかし、現在のところ、クライアントではハイドレーションされないものをサーバーでレンダリングする手段がありません。現在のところ、ページ全体を部分的にハイドレーションさせて、ハイドレーションマーカーを生成しない方法はありません。それはオール・オア・ナッシングです。部分的なハイドレーションは、将来的に検討したいと考えています。</p><p>最後に、すべてのリソースは <code>render</code> ツリーで定義する必要があります。リソースは自動的にシリアライズされてブラウザに取り込まれますが、これは <code>render</code> や <code>pipeTo</code> のメソッドがレンダリングの進行状況を把握しているからです。同様に、サーバーにはリアクティビティがないので、最初のレンダリングで Signal を更新して、ツリーの上位に反映されることを期待してはいけません。サスペンスの境界がある一方で、Solid の SSR は基本的にトップダウンです。</p><h2 id=\"ssr-%E3%82%92%E5%A7%8B%E3%82%81%E3%82%8B\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#ssr-%E3%82%92%E5%A7%8B%E3%82%81%E3%82%8B\">#</a> SSR を始める</h2><p>SSR の設定には注意が必要です。<a href=\"https://github.com/solidjs/solid/blob/main/packages/solid-ssr\">solid-ssr</a> パッケージにはいくつかの例があります。</p><p>しかし、この経験をよりスムーズにすることを目的とした新しいスターター <a href=\"https://github.com/solidjs/solid-start\">SolidStart</a> が開発されています。</p><h2 id=\"%E9%9D%99%E7%9A%84%E3%82%B5%E3%82%A4%E3%83%88%E7%94%9F%E6%88%90%E3%82%92%E5%A7%8B%E3%82%81%E3%82%8B\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E9%9D%99%E7%9A%84%E3%82%B5%E3%82%A4%E3%83%88%E7%94%9F%E6%88%90%E3%82%92%E5%A7%8B%E3%82%81%E3%82%8B\">#</a> 静的サイト生成を始める</h2><p><a href=\"https://github.com/solidjs/solid/blob/main/packages/solid-ssr\">solid-ssr</a> には、静的サイトや事前レンダリングされたサイトを生成するためのシンプルなユーティリティが同梱されています。詳しくは README をご覧ください。</p></section><section class=\"mt-10\"><h1 id=\"%E4%BB%96%E3%81%AE%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%81%A8%E3%81%AE%E6%AF%94%E8%BC%83\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E4%BB%96%E3%81%AE%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%81%A8%E3%81%AE%E6%AF%94%E8%BC%83\">#</a> 他のライブラリとの比較</h1><p>このセクションでは、多少の偏りは避けられませんが、Solid のソリューションが他のライブラリと比較してどのような位置にあるかを理解することが重要だと思っています。これはパフォーマンスの話ではありません。パフォーマンスについての決定的な情報は、<a href=\"https://github.com/krausest/js-framework-benchmark\">JS Framework Benchmark</a> をご覧ください。</p><h2 id=\"react\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#react\">#</a> React</h2><p>React は Solid に大きな影響を与えました。React の単方向フローや、Hooks API における読み取りと書き込みの明示的な分離は、Solid の API に影響を与えました。フレームワークではなく、単なる「レンダリングライブラリ」であるという目的以上のものです。Solid は、アプリケーション開発におけるデータ管理のアプローチ方法について強い意見を持っていますが、その実行を制約しようとはしません。</p><p>しかし、Solid は React の設計思想に沿うものであると同時に、根本的に異なる仕組みを持っています。React は仮想 DOM を使用し、Solid は使用しません。React の抽象化はトップダウンのコンポーネント分割で、レンダリングメソッドが繰り返し呼び出され、差分が発生します。一方 Solid は、各テンプレートを一度だけ全体的にレンダリングし、リアクティブグラフを構築した後、細かな変更に関連する命令を実行します。</p><h4 id=\"%E7%A7%BB%E8%A1%8C%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%82%A2%E3%83%89%E3%83%90%E3%82%A4%E3%82%B9%3A\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E7%A7%BB%E8%A1%8C%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%82%A2%E3%83%89%E3%83%90%E3%82%A4%E3%82%B9%3A\">#</a> 移行のためのアドバイス:</h4><p>Solid の更新モデルは、React や、React + MobX とは全く異なります。関数コンポーネントを <code>render</code> 関数と考えるのではなく、<code>constructor</code> と考えてください。分割代入や初期のプロパティアクセスはリアクティビティを失うことに注意してください。Solid のプリミティブにはフックルールのような制限がないので、自由にネストできます。また、リストの行に明示的なキーがなくても、「キー付き」の動作が可能です。最後に、仮想 DOM が存在しないので、<code>React.Children</code> や <code>React.cloneElement</code> のような仮想 DOM の命令的 API は意味を持ちません。これらを宣言的に使用する問題を解決する別の方法を見つけることをお勧めします。</p><h2 id=\"vue\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#vue\">#</a> Vue</h2><p>Solid は設計面では Vue の影響を特に受けていませんが、アプローチとしては同等です。どちらもリアクティブなシステムでプロキシを使用し、読み取りベースの自動追跡を行っています。しかし、似ているのはそこまでです。Vue の細かい依存関係の検出は、より細かい仮想 DOM とコンポーネントシステムに供給されるだけですが、Solid は DOM を直接更新することでその粒度を維持しています。</p><p>Vue は簡単さを重視し、Solid は透明性を重視しています。Vue 3 での Vue の新しい方向性は、Solid のアプローチとより一致しています。これらのライブラリが今後どのように進化していくかによって、時間が経てばもっと一致するかもしれません。</p><h4 id=\"%E7%A7%BB%E8%A1%8C%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%82%A2%E3%83%89%E3%83%90%E3%82%A4%E3%82%B9%3A-1\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E7%A7%BB%E8%A1%8C%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%82%A2%E3%83%89%E3%83%90%E3%82%A4%E3%82%B9%3A-1\">#</a> 移行のためのアドバイス:</h4><p>もう 1 つの最新リアクティブライブラリである Vue 3 からの移行は、なじみ深いものになるでしょう。Solid のコンポーネントは、Vue の <code>setup</code> 関数の最後にテンプレートをタグ付けするのとよく似ています。状態の派生を計算でオーバーラッピングすることに注意して、関数を試してみてください。リアクティビティが広く行き渡っています。Solid のプロキシは意図的に読み取り専用となっています。試す前にこきおろすのはやめましょう。</p><h2 id=\"svelte\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#svelte\">#</a> Svelte</h2><p>Svelte は、Solid もある程度採用しているプリコンパイルされた消えるフレームワークの先駆者です。どちらのライブラリも真にリアクティブであり、非常に小さな実行コードバンドルを生成できますが、小さなデモでは Svelte が勝っています。Solid は、宣言の際により多くの明示性を要求し、コンパイラによる暗黙の分析への依存度を下げていますが、これが Solid の優れたパフォーマンスの一因となっています。また、Solid はランタイムに多くの情報を保持しているため、大規模なアプリケーションでの拡張性に優れています。Solid の RealWorld デモの実装は、Svelte の実装よりも 25％ 小さいです。</p><p>どちらのライブラリも開発者がより少ないコードを書けるようにすることを目的としていますが、そのアプローチは全く異なります。Svelte 3 は、局所的な変化への対応を容易にするための最適化に焦点を当てており、プレーンなオブジェクトインタラクションと双方向バインディングに重点を置いています。対して Solid は、CQRS とイミュータブルなインターフェイスを意図的に採用することで、データフローに焦点を当てています。Svelte のテンプレート構文は間違いなく簡潔ですが、Solid では機能的なテンプレート構成により、多くの場合、Svelte よりも少ないコードで開発を行うことができます。</p><h4 id=\"%E7%A7%BB%E8%A1%8C%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%82%A2%E3%83%89%E3%83%90%E3%82%A4%E3%82%B9%3A-2\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E7%A7%BB%E8%A1%8C%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%82%A2%E3%83%89%E3%83%90%E3%82%A4%E3%82%B9%3A-2\">#</a> 移行のためのアドバイス:</h4><p>開発者体験は、いくつかの点で類似していますが、それは非常に異なる経験です。Solid のコンポーネントは安価なので、数を増やすことをためらう必要はありません。</p><h2 id=\"knockout.js\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#knockout.js\">#</a> Knockout.js</h2><p>このライブラリは、Knockout のおかげで成り立っています。細かい依存関係の検出のために、Knockout のモデルを近代化することが、このプロジェクトの動機でした。Knockout は 2010 年にリリースされ、Microsoft Explorer を IE6 までサポートしていますが、Solid の多くは IE をまったくサポートしていません。</p><p>Knockout のバインディングは、ランタイムに読み込まれる HTML の文字列に過ぎません。これらのバインディングは、クローンのコンテキスト（$parent など）に依存します。一方、Solid はテンプレートに JSX やタグ付きテンプレートリテラルを使用し、JavaScript の API を選択しています。</p><p>最大の違いは、Solid が変更をバッチ処理することで同期性を確保しているのに対し、Knockout は deferUpdates で遅延マイクロタスクキューを使用していることでしょう。</p><h4 id=\"%E7%A7%BB%E8%A1%8C%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%82%A2%E3%83%89%E3%83%90%E3%82%A4%E3%82%B9%3A-3\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E7%A7%BB%E8%A1%8C%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%82%A2%E3%83%89%E3%83%90%E3%82%A4%E3%82%B9%3A-3\">#</a> 移行のためのアドバイス:</h4><p>Knockout に慣れている人には、Solid のプリミティブは奇妙に見えるかもしれません。読み取り/書き込みの分離は意図的なもので、ただ人生を困難にするためではありません。State/Action (Flux) メンタルモデルの採用を検討してください。これらのライブラリは似ているように見えますが、異なるベストプラクティスを推進しています。</p><h2 id=\"lit-%26-lighterhtml\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#lit-%26-lighterhtml\">#</a> Lit &amp; LighterHTML</h2><p>これらのライブラリは非常に似ており、Solid にも影響を与えています。ほとんどの場合、Solid のコンパイルされたコードは、DOM の初期レンダリングを実行するために非常に似た方法を使用しています。テンプレート要素を複製したりコメントプレースホルダーの使用は、Solid とこれらのライブラリに共通するものです。</p><p>最大の違いは、これらのライブラリが仮想 DOM を使用していない一方で、レンダリングをトップダウンで同じように扱い、正常な状態を維持するためコンポーネント分割を必要とすることです。これに対して Solid は、きめ細かなリアクティブグラフを使って、変更された部分だけを更新し、最初のレンダリングでのみこの手法を共有しています。このアプローチは、ネイティブ DOM ならではの初期速度を利用しており、更新に対しても最もパフォーマンスの高いアプローチとなっています。</p><h4 id=\"%E7%A7%BB%E8%A1%8C%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%82%A2%E3%83%89%E3%83%90%E3%82%A4%E3%82%B9%3A-4\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E7%A7%BB%E8%A1%8C%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%82%A2%E3%83%89%E3%83%90%E3%82%A4%E3%82%B9%3A-4\">#</a> 移行のためのアドバイス:</h4><p>これらのライブラリはかなりミニマムで、その上に構築するのも簡単です。ただし、<code>&lt;MyComp/&gt;</code> は単なる HTMLElement（配列や関数）ではないことに注意してください。自分のものは JSX テンプレートの中に入れておくようにしましょう。ほとんどの場合、ホイスティングは機能しますが、これは HTMLElement のファクトリではなく、レンダリングライブラリであると考えるのがベストです。</p><h2 id=\"s.js\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#s.js\">#</a> S.js</h2><p>このライブラリは、Solid のリアクティブ設計に最も大きな影響を与えました。Solid は数年前から S.js を内部で使用していましたが、機能セットの違いから別々の道を歩むことになりました。S.js は、これまでで最も効率的なリアクティブライブラリの 1 つです。デジタル回路のように同期したタイムステップですべてをモデル化し、MobX のような複雑なメカニズムを多用することなく一貫性を確保しています。Solid のリアクティビティは、最終的には S と MobX のハイブリッドのようなものです。これにより、多くのリアクティブライブラリ（Knockout、MobX、Vue）よりも高いパフォーマンスが得られる一方で、開発者のメンタルモデルは簡単に保つことができます。最終的には S.js の方がリアクティブライブラリとしての性能は高いのですが、その差は最も過酷な合成ベンチマーク以外ではほとんど気になりません。</p><h2 id=\"rxjs\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#rxjs\">#</a> RxJS</h2><p>RxJS はリアクティブライブラリです。Solid は Observable データという似たようなアイデアを持っていますが、オブザーバーパターンのはるかに異なる応用を使用しています。Signal は Observable の単純なバージョンのようなものですが（次のものだけ）、自動的な依存関係検出のパターンは RxJS の 100 以上の演算子を凌駕しています。Solid もこのようなアプローチを取ることができましたし、実際に初期のバージョンのライブラリには同様の演算子が含まれていましたが、ほとんどの場合、計算で独自の変換ロジックを書く方が簡単です。Observable がコールドスタート、ユニキャスト、プッシュベースであるのに対し、クライアント上の多くの問題はホットスタート、マルチキャストであり、Solid のデフォルトの動作となります。</p><h2 id=\"%E3%81%9D%E3%81%AE%E4%BB%96\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#%E3%81%9D%E3%81%AE%E4%BB%96\">#</a> その他</h2><p>Angular や他のいくつかの人気のあるライブラリは、この比較では注目に値しません。これらのライブラリを使用した経験がないため、適切な比較ができないのです。一般的に、Solid は大規模なフレームワークとの共通点が少なく、正面から比較することは非常に困難です。</p></section><section class=\"mt-10\"><h1 id=\"faq\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#faq\">#</a> FAQ</h1><h3 id=\"1.-%E4%BB%AE%E6%83%B3-dom-%E3%81%AA%E3%81%97%E3%81%AE-jsx%EF%BC%9F-%E3%83%99%E3%83%BC%E3%83%91%E3%83%BC%E3%82%A6%E3%82%A7%E3%82%A2%EF%BC%88%E6%A6%82%E5%BF%B5%E3%81%A0%E3%81%91%E3%81%A7%E5%AE%9F%E6%85%8B%E3%81%AE%E3%81%AA%E3%81%84%E3%82%BD%E3%83%95%E3%83%88%EF%BC%89%E3%81%A7%E3%81%99%E3%81%8B%EF%BC%9F-%E4%BB%96%E3%81%AE%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF%E3%81%AE%E4%BD%9C%E8%80%85%E3%81%8C%E3%81%93%E3%82%8C%E3%81%AF%E4%B8%8D%E5%8F%AF%E8%83%BD%E3%81%A0%E3%81%A8%E8%A8%80%E3%81%A3%E3%81%A6%E3%81%84%E3%82%8B%E3%82%88%E3%81%86%E3%81%AA%E6%9C%89%E5%90%8D%E3%81%AA%E6%84%8F%E8%A6%8B%E3%82%92%E8%81%9E%E3%81%84%E3%81%9F%E3%81%93%E3%81%A8%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#1.-%E4%BB%AE%E6%83%B3-dom-%E3%81%AA%E3%81%97%E3%81%AE-jsx%EF%BC%9F-%E3%83%99%E3%83%BC%E3%83%91%E3%83%BC%E3%82%A6%E3%82%A7%E3%82%A2%EF%BC%88%E6%A6%82%E5%BF%B5%E3%81%A0%E3%81%91%E3%81%A7%E5%AE%9F%E6%85%8B%E3%81%AE%E3%81%AA%E3%81%84%E3%82%BD%E3%83%95%E3%83%88%EF%BC%89%E3%81%A7%E3%81%99%E3%81%8B%EF%BC%9F-%E4%BB%96%E3%81%AE%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF%E3%81%AE%E4%BD%9C%E8%80%85%E3%81%8C%E3%81%93%E3%82%8C%E3%81%AF%E4%B8%8D%E5%8F%AF%E8%83%BD%E3%81%A0%E3%81%A8%E8%A8%80%E3%81%A3%E3%81%A6%E3%81%84%E3%82%8B%E3%82%88%E3%81%86%E3%81%AA%E6%9C%89%E5%90%8D%E3%81%AA%E6%84%8F%E8%A6%8B%E3%82%92%E8%81%9E%E3%81%84%E3%81%9F%E3%81%93%E3%81%A8%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82\">#</a> 1. 仮想 DOM なしの JSX？ ベーパーウェア（概念だけで実態のないソフト）ですか？ 他のフレームワークの作者がこれは不可能だと言っているような有名な意見を聞いたことがあります。</h3><p>React の更新モデルを持っていなければ可能です。JSX は他のテンプレート DSL と同じです。特定の方法ではより柔軟性があります。任意の JavaScript を挿入するのは難しい場合もありますが、スプレッド演算子をサポートするのと変わりません。つまり、これはベーパーウェアではなく、最もパフォーマンスが高いことが証明されているアプローチなのです。</p><p>本当のメリットは、拡張性の高さにあります。コンパイラが最適なネイティブ DOM 更新を提供してくれますが、React のようなライブラリの自由度が高く、Render Props や Higher Order Components などのテクニックを使ったコンポーネントを、リアクティブな「フック」と一緒に書くことができます。Solid の制御フローがどのように機能するかが気に入らない？ 自分で書きましょう。</p><h3 id=\"2.-solid-%E3%81%A9%E3%82%8C%E3%81%BB%E3%81%A9%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%81%8C%E5%84%AA%E3%82%8C%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%81%8B%EF%BC%9F\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#2.-solid-%E3%81%A9%E3%82%8C%E3%81%BB%E3%81%A9%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%81%8C%E5%84%AA%E3%82%8C%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%81%8B%EF%BC%9F\">#</a> 2. Solid どれほどパフォーマンスが優れていますか？</h3><p>何か 1 つを挙げることができればいいのですが、実際には多くの重要な設計上の決定が組み合わされています。</p><ol> <li>明示的なリアクティビティにより、リアクティブであるべきものだけを追跡します。</li> <li>初期生成を考慮してコンパイルする。Solid はヒューリスティックな手法を用いて粒度を緩め、計算回数を減らす一方で、重要な更新は粒度とパフォーマンスを維持しています。</li> <li>リアクティブな式は単なる関数です。これにより、不要なラッパーや同期のオーバーヘッドを取り除いた遅延 props 評価による「消えるコンポーネント」が可能になります。</li> </ol><p>これらは現在のところ、Solid が競合に対して優位に立つための組み合わせであり、独特な技術です。</p><h3 id=\"3.-react-%E3%81%A8%E3%81%AE%E4%BA%92%E6%8F%9B%E6%80%A7%E3%81%AF%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%81%8B%EF%BC%9F\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#3.-react-%E3%81%A8%E3%81%AE%E4%BA%92%E6%8F%9B%E6%80%A7%E3%81%AF%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%81%8B%EF%BC%9F\">#</a> 3. React との互換性はありますか？</h3><p>いいえ、これからもならないでしょう。API は似ていて、コンポーネントは小さな編集で移動できることが多いのですが、更新モデルは根本的に異なります。React コンポーネントは何度もレンダリングされるため、Hooks 以外のコードは非常に異なって動作します。クロージャやフックのルールは不要なだけでなく、ここでは動作しない方法で使用できます。</p><p>一方で、Vue 互換は可能でしょう。現在のところ実装の予定はありませんが。</p><h3 id=\"4.-%E3%81%AA%E3%81%9C%E5%88%86%E5%89%B2%E4%BB%A3%E5%85%A5%E3%81%8C%E5%8B%95%E4%BD%9C%E3%81%97%E3%81%AA%E3%81%84%E3%81%AE%E3%81%A7%E3%81%99%E3%81%8B%EF%BC%9F-%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E5%85%A8%E4%BD%93%E3%82%92%E9%96%A2%E6%95%B0%E3%81%A7%E3%83%A9%E3%83%83%E3%83%97%E3%81%99%E3%82%8C%E3%81%B0%E8%A7%A3%E6%B1%BA%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%93%E3%81%A8%E3%81%AB%E6%B0%97%E3%81%A5%E3%81%8D%E3%81%BE%E3%81%97%E3%81%9F%E3%80%82\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#4.-%E3%81%AA%E3%81%9C%E5%88%86%E5%89%B2%E4%BB%A3%E5%85%A5%E3%81%8C%E5%8B%95%E4%BD%9C%E3%81%97%E3%81%AA%E3%81%84%E3%81%AE%E3%81%A7%E3%81%99%E3%81%8B%EF%BC%9F-%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E5%85%A8%E4%BD%93%E3%82%92%E9%96%A2%E6%95%B0%E3%81%A7%E3%83%A9%E3%83%83%E3%83%97%E3%81%99%E3%82%8C%E3%81%B0%E8%A7%A3%E6%B1%BA%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%93%E3%81%A8%E3%81%AB%E6%B0%97%E3%81%A5%E3%81%8D%E3%81%BE%E3%81%97%E3%81%9F%E3%80%82\">#</a> 4. なぜ分割代入が動作しないのですか？ コンポーネント全体を関数でラップすれば解決できることに気づきました。</h3><p>リアクティビティは Prop と Store オブジェクトのプロパティアクセスで発生します。バインディングやリアクティブな計算の外でそれらを参照しても追跡されません。これらの内部では分割代入は全く問題ありません。</p><p>しかし、コンポーネント全体を関数でラップすることは、無責任に行うべきではありません。Solid には仮想 DOM がありません。そのため、追跡された変更は、関数全体を再度実行し、すべてを再作成することになります。これはやめておきましょう。</p><h3 id=\"5.-%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E3%82%B5%E3%83%9D%E3%83%BC%E3%83%88%E3%82%92%E8%BF%BD%E5%8A%A0%E3%81%97%E3%81%A6%E3%81%8F%E3%82%8C%E3%81%BE%E3%81%99%E3%81%8B%EF%BC%9F-%E3%83%A9%E3%82%A4%E3%83%95%E3%82%B5%E3%82%A4%E3%82%AF%E3%83%AB%E3%81%AE%E6%96%B9%E3%81%8C%E6%8E%A8%E8%AB%96%E3%81%97%E3%82%84%E3%81%99%E3%81%84%E3%81%A8%E6%80%9D%E3%81%84%E3%81%BE%E3%81%99%E3%80%82\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#5.-%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E3%82%B5%E3%83%9D%E3%83%BC%E3%83%88%E3%82%92%E8%BF%BD%E5%8A%A0%E3%81%97%E3%81%A6%E3%81%8F%E3%82%8C%E3%81%BE%E3%81%99%E3%81%8B%EF%BC%9F-%E3%83%A9%E3%82%A4%E3%83%95%E3%82%B5%E3%82%A4%E3%82%AF%E3%83%AB%E3%81%AE%E6%96%B9%E3%81%8C%E6%8E%A8%E8%AB%96%E3%81%97%E3%82%84%E3%81%99%E3%81%84%E3%81%A8%E6%80%9D%E3%81%84%E3%81%BE%E3%81%99%E3%80%82\">#</a> 5. クラスコンポーネントのサポートを追加してくれますか？ ライフサイクルの方が推論しやすいと思います。</h3><p>クラスコンポーネントをサポートすることは意図していません。Solid のライフサイクルは、リアクティブシステムのスケジューリングに結びついており、人為的なものです。クラスを作ることはできますが、事実上、イベントハンドラ以外のコードは render 関数を含め、基本的にコンストラクタで実行されます。これは、データの粒度を小さくするための言い訳のための構文に過ぎません。</p><p>ライフサイクルではなく、データとその振る舞いをまとめてください。これは何十年にもわたって機能してきたリアクティブなベストプラクティスです。</p><h3 id=\"6.-%E7%A7%81%E3%81%AF-jsx-%E3%81%8C%E3%81%A8%E3%81%A6%E3%82%82%E5%AB%8C%E3%81%84%E3%81%AA%E3%81%AE%E3%81%A7%E3%81%99%E3%81%8C%E3%80%81%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88-dsl-%E3%81%AE%E5%8F%AF%E8%83%BD%E6%80%A7%E3%81%AF%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%81%8B%EF%BC%9F-%E3%81%82%E3%80%81%E3%82%BF%E3%82%B0%E4%BB%98%E3%81%8D%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88%E3%83%AA%E3%83%86%E3%83%A9%E3%83%AB%2Fhyperscript-%E3%81%8C%E3%81%82%E3%82%8B%E3%82%93%E3%81%A7%E3%81%99%E3%81%AD%E3%80%82%E4%BD%BF%E3%81%A3%E3%81%A6%E3%81%BF%E3%82%88%E3%81%86%E3%81%8B%E3%81%AA%E2%80%A6%E2%80%A6%E3%80%82\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#6.-%E7%A7%81%E3%81%AF-jsx-%E3%81%8C%E3%81%A8%E3%81%A6%E3%82%82%E5%AB%8C%E3%81%84%E3%81%AA%E3%81%AE%E3%81%A7%E3%81%99%E3%81%8C%E3%80%81%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88-dsl-%E3%81%AE%E5%8F%AF%E8%83%BD%E6%80%A7%E3%81%AF%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%81%8B%EF%BC%9F-%E3%81%82%E3%80%81%E3%82%BF%E3%82%B0%E4%BB%98%E3%81%8D%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88%E3%83%AA%E3%83%86%E3%83%A9%E3%83%AB%2Fhyperscript-%E3%81%8C%E3%81%82%E3%82%8B%E3%82%93%E3%81%A7%E3%81%99%E3%81%AD%E3%80%82%E4%BD%BF%E3%81%A3%E3%81%A6%E3%81%BF%E3%82%88%E3%81%86%E3%81%8B%E3%81%AA%E2%80%A6%E2%80%A6%E3%80%82\">#</a> 6. 私は JSX がとても嫌いなのですが、テンプレート DSL の可能性はありますか？ あ、タグ付きテンプレートリテラル/HyperScript があるんですね。使ってみようかな……。</h3><p>やめてください。ここでやめておきましょう。Svelte がテンプレートを使って最適化された DOM 命令を作成するのと同じように、私たちは JSX を使っています。タグ付きテンプレートリテラルや HyperScript のソリューションは、それ自体はとても素晴らしいものかもしれませんが、ビルド不可の要件のような現実的な理由がない限りあらゆる面で劣っています。バンドルが大きくなり、パフォーマンスが低下し、値のラップを手動で行う必要があります。</p><p>選択肢があるのは良いことですが、Solid の JSX はここでは本当に最適なソリューションです。テンプレート DSL も制限が多いとはいえ素晴らしいですが、JSX は無料で多くのことを提供してくれます。TypeScript、既存のパーサー、シンタックスハイライト、TypeScript、Prettier、コード補完、そして最後に欠かせないのが TypeScript です。</p><p>他のライブラリもこれらの機能のサポートを追加してきましたが、それは膨大な努力を必要とし、まだ不完全で、常にメンテナンスに頭を悩ませています。これは本当に現実的なスタンスを取っています。</p><h3 id=\"7.-signal-%E3%81%A8%E3%82%B9%E3%83%88%E3%82%A2%E3%81%AF%E3%81%A9%E3%81%AE%E3%82%88%E3%81%86%E3%81%AA%E5%A0%B4%E5%90%88%E3%81%AB%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E3%81%AE%E3%81%A7%E3%81%99%E3%81%8B%EF%BC%9F-%E3%81%AA%E3%81%9C%E3%81%93%E3%82%8C%E3%82%89%E3%81%AF%E9%81%95%E3%81%86%E3%81%AE%E3%81%A7%E3%81%99%E3%81%8B%EF%BC%9F\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#7.-signal-%E3%81%A8%E3%82%B9%E3%83%88%E3%82%A2%E3%81%AF%E3%81%A9%E3%81%AE%E3%82%88%E3%81%86%E3%81%AA%E5%A0%B4%E5%90%88%E3%81%AB%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E3%81%AE%E3%81%A7%E3%81%99%E3%81%8B%EF%BC%9F-%E3%81%AA%E3%81%9C%E3%81%93%E3%82%8C%E3%82%89%E3%81%AF%E9%81%95%E3%81%86%E3%81%AE%E3%81%A7%E3%81%99%E3%81%8B%EF%BC%9F\">#</a> 7. Signal とストアはどのような場合に使用するのですか？ なぜこれらは違うのですか？</h3><p>ストアはネストした値を自動的にラップするので、深いデータ構造やモデルのようなものに最適です。それ以外のほとんどの用途では、Signal は軽量で、素晴らしい働きをします。</p><p>これらを 1 つのものとしてまとめたいところですが、プリミティブをプロキシすることはできません。関数は最もシンプルなインターフェイスで、あらゆるリアクティブな式（状態のアクセスを含む）をトランスポート上で 1 つにまとめることができるため、ユニバーサルな API を提供します。Signal や状態に好きな名前をつけることができ、最小限の機能にとどめることができます。エンドユーザーに <code>.get()</code> <code>.set()</code> の入力を強要したり、さらに悪いことに <code>.value</code> の入力を強要したりすることは絶対に避けたいことです。少なくとも、前者は簡潔にするためにエイリアスを付けることができますが、後者は関数を呼び出すための最も簡潔な方法に過ぎません。</p><h3 id=\"8.-vue-%E3%81%AE%E3%82%88%E3%81%86%E3%81%AB-solid-%E3%81%AE%E3%82%B9%E3%83%88%E3%82%A2%E3%81%AB%E5%80%A4%E3%82%92%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%84%E3%81%AE%E3%81%AF%E3%81%AA%E3%81%9C%E3%81%A7%E3%81%99%E3%81%8B%E3%80%82-svelte%E3%80%81%E3%81%BE%E3%81%9F%E3%81%AF-mobx%EF%BC%9F-%E5%8F%8C%E6%96%B9%E5%90%91%E3%83%90%E3%82%A4%E3%83%B3%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E3%81%AF%E3%81%A9%E3%81%93%E3%81%AB%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%81%8B%EF%BC%9F\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#8.-vue-%E3%81%AE%E3%82%88%E3%81%86%E3%81%AB-solid-%E3%81%AE%E3%82%B9%E3%83%88%E3%82%A2%E3%81%AB%E5%80%A4%E3%82%92%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%84%E3%81%AE%E3%81%AF%E3%81%AA%E3%81%9C%E3%81%A7%E3%81%99%E3%81%8B%E3%80%82-svelte%E3%80%81%E3%81%BE%E3%81%9F%E3%81%AF-mobx%EF%BC%9F-%E5%8F%8C%E6%96%B9%E5%90%91%E3%83%90%E3%82%A4%E3%83%B3%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E3%81%AF%E3%81%A9%E3%81%93%E3%81%AB%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%81%8B%EF%BC%9F\">#</a> 8. Vue のように Solid のストアに値を割り当てることができないのはなぜですか。 Svelte、または MobX？ 双方向バインディングはどこにありますか？</h3><p>リアクティビティは強力なツールですが、同時に危険なツールでもあります。MobX はこのことを理解していて、Strict モードと Actions を導入して、更新が発生する場所や時間を制限しています。データのコンポーネントツリー全体を扱う Solid では、React から何かを学べることが明らかになりました。同じ契約を持つための手段を提供する限り、実際にイミュータブルである必要はありません。</p><p>状態を更新する能力を渡せるかどうかは、状態を渡すかどうかを決めるよりも間違いなく重要です。だから、それを分離できることは重要であり、読み取りがイミュータブルである場合にのみ可能です。また、細かく更新できるのであれば、不変性のコストを払う必要はありません。幸いなことに、ImmutableJS と Immer の間には大量の先行技術があります。皮肉なことに、Solid はミュータブルな内部とイミュータブルなインターフェイスを持つ逆 Immer のように振る舞います。</p><h3 id=\"9.-solid-%E3%81%AE%E3%83%AA%E3%82%A2%E3%82%AF%E3%83%86%E3%82%A3%E3%83%93%E3%83%86%E3%82%A3%E3%82%92%E5%8D%98%E4%BD%93%E3%81%A7%E4%BD%BF%E3%81%86%E3%81%93%E3%81%A8%E3%81%AF%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%81%8B%EF%BC%9F\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#9.-solid-%E3%81%AE%E3%83%AA%E3%82%A2%E3%82%AF%E3%83%86%E3%82%A3%E3%83%93%E3%83%86%E3%82%A3%E3%82%92%E5%8D%98%E4%BD%93%E3%81%A7%E4%BD%BF%E3%81%86%E3%81%93%E3%81%A8%E3%81%AF%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%81%8B%EF%BC%9F\">#</a> 9. Solid のリアクティビティを単体で使うことはできますか？</h3><p>もちろんです。単体のパッケージは提供していませんが、コンパイラなしの Solid をインストールし、リアクティブプリミティブを使用することは簡単です。きめ細かいリアクティビティの利点の 1 つは、ライブラリに依存しないことです。それどころか、ほとんどすべてのリアクティブライブラリがこの方法で動作します。それが <a href=\"https://github.com/solidjs/solid\">Solid</a> に影響を与えたものであり、その基礎となる <a href=\"https://github.com/ryansolid/dom-expressions\">DOM Expressions library</a> が純粋にリアクティブシステムからレンダラーを作るきっかけとなりました。</p><p>試しにいくつか挙げてみましょう: <a href=\"https://github.com/solidjs/solid\">Solid</a>、<a href=\"https://github.com/mobxjs/mobx\">MobX</a>、<a href=\"https://github.com/knockout/knockout\">Knockout</a>、<a href=\"https://github.com/sveltejs/svelte\">Svelte</a>、<a href=\"https://github.com/adamhaile/S\">S.js</a>、<a href=\"https://github.com/Riim/cellx\">CellX</a>、<a href=\"https://github.com/ds300/derivablejs\">Derivable</a>、<a href=\"https://github.com/luwes/sinuous\">Sinuous</a>、そして最近では <a href=\"https://github.com/vuejs/vue\">Vue</a> などです。リアクティブなライブラリを作るには、例えば <a href=\"https://github.com/Polymer/lit-html\">lit-html</a> のようにレンダラーにタグ付けするよりもはるかに多くのことが必要ですが、感触をつかむには良い方法です。</p><h3 id=\"10.-solid-%E3%81%AB%E3%81%AF%E3%80%81next.js-%E3%82%84-material-components-%E3%81%AE%E3%82%88%E3%81%86%E3%81%AA%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%81%AF%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%81%8B%EF%BC%9F\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#10.-solid-%E3%81%AB%E3%81%AF%E3%80%81next.js-%E3%82%84-material-components-%E3%81%AE%E3%82%88%E3%81%86%E3%81%AA%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%81%AF%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%81%8B%EF%BC%9F\">#</a> 10. Solid には、Next.js や Material Components のようなライブラリはありますか？</h3><p>私たちの知る限りありません。もしライブラリ構築に興味があれば、<a href=\"https://discord.com/invite/solidjs\">Discord</a> ですぐに構築のお手伝いをいたします。基本的なものは揃っているので、あとはそれをベースにしていくだけです。</p></section>"
}