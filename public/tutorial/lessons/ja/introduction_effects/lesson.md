Signal は追跡可能な値ですが、均衡の半分にすぎません。 残りの半分はオブザーバーであり、計算とも呼ばれます。 最も基本的な計算は、システムの出力である副作用を生み出す Effect と呼ばれます。

Effect は `solid-js` から `createEffect` をインポートすることで作成できます。実行を監視する関数を受け取ります。実行中に読み取られたすべての Signal を自動的にサブスクライブし、それらの Signal の値が変更されるたびに再実行します。


それでは、`count` が変化するたびに再実行される Effect を作成してみましょう。

```jsx
createEffect(() => {
  console.log("The count is now", count());
});
```

`Count` Signal を更新するために、ボタンにクリックハンドラーをアタッチします。

```jsx
<button onClick={() => setCount(count() + 1)}>Click Me</button>
```

これで、ボタンをクリックするとコンソールに書き込まれるはずです。これは比較的簡単な例ですが、Solid の仕組みを理解するには、JSX 内のすべての式が、依存する Signal が変化するたびに再実行される、個別にラップされた Effect である可能性があることを想像する必要があります。これが、Solid でのすべてのレンダリングの仕組みです。Solid の視点では、「すべてのレンダリングは、リアクティブシステムの副作用に過ぎない」のです。

開発者が `createEffect` で作成した Effect は、レンダリングが完了した後に実行され、主に DOM と相互作用するレンダリング後の更新をスケジュールするために使用されます。
