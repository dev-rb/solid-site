Сторы в Solid позволяют нам использовать вложенную реактивность. Это прокси-объекты (`proxy objects`), свойства которых можно отслеживать, и они могут содержать другие объекты, которые сами автоматически оборачиваются в прокси объекты, и так далее.

Чтобы облегчить использование ресурсов, Solid создает базовые Сигналы только для свойств, доступ к которым осуществляется в областях отслеживания. Таким образом все Сигналы в сторах создаются лениво, в момент запроса.

Вызов createStore принимает начальное значение и возвращает кортеж (`tuple`) для чтения / записи, аналогичный Сигналам. Первый элемент - это прокси, доступный только-для-чтения, а второй - функция-сеттер (`setter function`).

Функция-сеттер в своей самой простой форме принимает объект, свойства которого будут объединены с текущим состоянием. Она также поддерживает синтаксис пути для свойства, поэтому мы легко сможем выполнять вложенные обновления. Таким образом, мы по-прежнему сохраняем нашу реактивность, но точно определять обновления.

> Синтаксис пути Solid имеет множество форм и включает мощный синтаксис для назначения итераций и диапазонов. Обратитесь к документации API за подробностями.

Давайте посмотрим, насколько проще добиться вложенной реактивности с помощью Store. Мы можем заменить инициализацию нашего компонента следующим образом:

```js
const [store, setStore] = createStore({ todos: [] });
const addTodo = (text) => {
  setStore('todos', (todos) => [...todos, { id: ++todoId, text, completed: false }]);
};
const toggleTodo = (id) => {
  setStore('todos', (t) => t.id === id, 'completed', (completed) => !completed);
};
```

В данном примере мы используем синтаксис пути Store с функцией-сеттером, которые позволяют нам получить предыдущее состояние и возвращать новое состояние для вложенных значений.

Вот и все. Для того, чтобы посмотреть как происходят обновление вы можете установить флажок и посмотреть в Консоли (`Console`)
