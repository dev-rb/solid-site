Чаще всего сторы в Solid создаются с использованием Solid `Store` прокси. Но иногда мы хотим использовать библиотеки с иммутабельной (`immutable`) моделью такие как Redux, Apollo или XState и мы хотим использовать точные обновления с ними.

В этом примере мы разберем как создать простую обертку вокруг Redux. Вы можете увидеть реализацию в `useRedux.tsx`. Определение стора и действий (`actions`) находятся в других файлах.

Мы создали объект Store и подписались на хранилище Redux для обновления состояния при изменениях.

```js
const [state, setState] = createStore(store.getState());
const unsubscribe = store.subscribe(
  () => setState(store.getState())
);
```

Если вы поиграете с демо и добавите или отключите из него элементы то увидите, что оно хорошо работает. Однако не очевидно, что рендеринг неэффективен. Обратите внимание на console.log не только при создании, но и всякий раз, когда вы устанавливаете флажок.

Причина в том, что Solid по умолчанию не отслеживает изменения. Он предполагает, что каждый элемент является новым, и заменяет его. Если ваши данные меняются незначительно, то вам не нужно их отслеживать вам не нужно отслеживать изменения. Но что, если вам это необходимо?

Solid предоставляет метод сравнения `reconcile`, который расширяет возможности вызова` setStore` и позволяет нам сравнивать данные из этих иммутабельных (`immutable`) источников, уведомляя только о настоящих изменениях.

Давайте обновим этот код до:

```js
const [state, setState] = createStore(store.getState());
const unsubscribe = store.subscribe(
  () => setState(reconcile(store.getState()))
);
```

Теперь пример работает так, как и следовало ожидать, мы запускаем код для создания только в самом начале.

Это не единственный способ решить эту проблему, и вы видели, что некоторые фреймворки имеют свойство `key` при рендере массива шаблонов с помощью цикла. Проблема в том, что, сделав это частью шаблона по умолчанию, вам всегда нужно запускать согласование списков и всегда нужно следить за всеми дочерними элементами на предмет потенциальных изменений, даже во фреймворках, которые компилируются. Подход, ориентированный на данные, не только позволяет применять это вне шаблонов, но и позволяет использовать их только тогда, когда вам необходимо. Если учесть, что внутреннему управлению состоянием это не нужно, это означает, что мы по умолчанию обеспечиваем лучшую производительность.

Конечно, нет проблем с использованием `reconcile`, когда оно вам нужно. Иногда простой редюсер - отличный способ организовать обновление данных. В данном случае мы сможем использовать `reconcile` и создать наш собственный примитив` useReducer`:

```js
const useReducer = (reducer, state) => {
  const [store, setStore] = createStore(state);
  const dispatch = (action) => {
    state = reducer(state, action);
    setStore(reconcile(state));
  }
  return [store, dispatch];
};
```

Поведение `reconcile` можно настроить. Мы можем установить собственный `key`, и есть опция `merge`, которая игнорирует структурное клонирование и различает только листья.