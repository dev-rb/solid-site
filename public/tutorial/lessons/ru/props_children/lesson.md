Производительность Solid отчасти объясняется тем, что наши компоненты в основном представляют собой просто вызовы функций. Способ распространения обновлений заключается в том, что компилятор оборачивает потенциально реактивные выражения в геттеры объектов. Вы можете представить вывод компилятора:

```jsx
// этот JSX
<MyComp dynamic={mySignal()}>
	<Child />
</MyComp>;

// превращается в:
MyComp({
	get dynamic() {
		return mySignal();
	},
	get children() {
		return Child();
	},
});
```

Это означает, что эти пропсы вычисляются лениво — в момент вызова. Это сохраняет реактивность без добавления посторонних оберток или синхронизации. Однако это означает, что повторный доступ может привести к созданию лишних потомков (`children`): компонентов или элементов.

В подавляющем большинстве случаев вы просто вставляете пропсы в JSX, поэтому проблем нет. Однако, когда вы работаете с потомками, есть опасность создать их по несколько раз.

Поэтому у Solid есть `children` хелпер (`helper`). Этот метод создает `Memo` вокруг свойства `children` и управляет любыми вложенными дочерние реактивными ссылками, так что вы можете напрямую взаимодействовать с дочерними элементами.

В этом примере у нас есть динамический список, и мы хотим установить свойство стиля элементов `color`. Если бы мы напрямую взаимодействовали с `props.children`, мы не только создавали бы узлы несколько раз, но и обнаружили бы, что` props.children` является функцией, которую `Memo` возвращает из `<For>`.

Вместо этого давайте воспользуемся хелпером `children` внутри `color-list.tsx`:

```jsx
export default function ColoredList(props) {
	const c = children(() => props.children);
	return <>{c()}</>;
}
```

Теперь, чтобы обновить наши элементы, давайте создадим Эффект:

```jsx
createEffect(() => c().forEach(item => (item.style.color = props.color)));
```
